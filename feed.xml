<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://bencbartlett.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bencbartlett.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-11-21T21:39:52+00:00</updated><id>https://bencbartlett.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Teaching ChatGPT to do quantum computing with cat emojis üò∫</title><link href="https://bencbartlett.github.io/blog/chatgpt-quantum-computing/" rel="alternate" type="text/html" title="Teaching ChatGPT to do quantum computing with cat emojis üò∫"/><published>2022-12-06T00:00:00+00:00</published><updated>2022-12-06T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/chatgpt-quantum-computing</id><content type="html" xml:base="https://bencbartlett.github.io/blog/chatgpt-quantum-computing/"><![CDATA[<p>You have probably seen some of the things that you can do with OpenAI‚Äôs new <a href="https://chat.openai.com/chat#">ChatGPT</a> which was released last week: this unnervingly human-like language model can <a href="https://maximumeffort.substack.com/p/i-taught-chatgpt-to-invent-a-language">invent a fictional language</a>, <a href="https://www.engraved.blog/building-a-virtual-machine-inside/">emulate a virtual machine</a>, and <a href="https://twitter.com/amasad/status/1598042665375105024">debug code for you</a>.</p> <p>Yesterday I finally spent some time playing around with ChatGPT and I am really impressed by how powerful it is. I decided to try to teach ChatGPT to implement a new computational model from the ground up. The model, based on ‚Äúmewbits‚Äù is equivalent to quantum computing and qubits, but the catch is that I didn‚Äôt tell ChatGPT what I was having it do; I just told it the rules of the game for this abstract computational model. Over the course of this transcript, the following happens:</p> <ul> <li> <p>ChatGPT is introduced to a new computational model. The basic unit of information of this model is a ‚Äúmewbit‚Äù, which can be in any normalized linear combination of two states: üòæ and üò∫.</p> </li> <li> <p>ChatGPT is introduced to how measurement (state collapse) behave for mewbits. I then introduce some basic operations you can do on mewbits, including not (Pauli-X) and H (Hadamard). It understands what these operations do and successfully completes several exercises I give to it.</p> </li> <li> <p>ChatGPT writes a <code class="language-plaintext highlighter-rouge">mewbit</code> class in Python, which tracks the internal state of the mewbit and has methods for operations and measurements you can do on a mewbit. It adds comments explaining what is going on.</p> </li> <li> <p>I explain the basics of quantum entanglement to ChatGPT. It constructs a program to emulate a system of multiple mewbits and understands how to generalize single-mewbit operations to this multi-mewbit system.</p> </li> <li> <p>I introduce the concept of a two-mewbit CNOT gate and I explain in plain english how to simulate joint measurements. ChatGPT understands, completes exercises successfully, and updates its Python class to incorporate this complex gate.</p> </li> <li> <p>I ask ChatGPT to write a script which would generate 100 entangled <a href="https://en.wikipedia.org/wiki/Bell_state#Creating_Bell_states">Bell pair</a>s and measure the system states, then plot the results.</p> </li> <li> <p>Finally, I asked ChatGPT if any of this sounded familiar, and it understood that the ‚Äúmewbits‚Äù I described to it were actually qubits!</p> </li> </ul> <h2 id="teaching-chatgpt-about-mewbits">Teaching ChatGPT about mewbits</h2> <p><img src="/assets/img/image.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-1.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="how-does-measurement-work-on-mewbits">How does measurement work on mewbits?</h2> <p><img src="/assets/img/image-4.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-5.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="teaching-chatgpt-about-quantum-gates">Teaching ChatGPT about quantum gates</h2> <p><img src="/assets/img/image-6.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-7.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>At this point, ChatGPT makes the inference that üòæ = 1*üòæ+0*üò∫:</p> <p><img src="/assets/img/image-8.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-9.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>Now we introduce a more complicated concept: the <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Hadamard_gate">Hadamard gate</a>:</p> <p><img src="/assets/img/image-10.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="chatgpt-formalizes-what-it-has-learned-into-python-code">ChatGPT formalizes what it has learned into Python code</h2> <p>At this point ChatGPT clearly understands the concepts and answers examples correctly, but I would like to see what it thinks is actually going on under the hood, so I ask it to formalize what it has learned into Python code:</p> <p><img src="/assets/img/image-12.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-11.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>And because all good code should have comments:</p> <p><img src="/assets/img/image-15.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>Since it seems ChatGPT forgot to add measurement as a thing you could do to a mewbit, I asked it to add that in as well:</p> <p><img src="/assets/img/image-16.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="multi-mewbit-systems">Multi-mewbit systems</h2> <p>At this point I made the considerable jump in complexity to explaining how multi-mewbit systems behave, explaining a simplified version of the mechanics of quantum entanglement to ChatGPT. I also explained how you can perform operations on a single mewbit in the system, changing the state of that mewbit but leaving the rest unchanged. Notably, ChatGPT inferred that this updates the state of the multi-mewbit system:</p> <p><img src="/assets/img/image-17.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-19.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="multi-mewbit-gates">Multi-mewbit gates</h2> <p><img src="/assets/img/image-20.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>This was a complex idea to explain to an AI, and I admit I had to make a few attempts at explaining it properly before ChatGPT was able to understand what I meant. However, as you‚Äôll see, ChatGPT makes an error and then corrects itself:</p> <p><img src="/assets/img/image-21.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>I now ask it to incorporate its new knowledge into its existing understanding of mewbit systems:</p> <p><img src="/assets/img/image-22.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="joint-measurement-of-multiple-mewbits">Joint measurement of multiple mewbits</h2> <p><img src="/assets/img/image-23.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p><img src="/assets/img/image-24.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="putting-it-all-together-bell-state-preparation">Putting it all together: Bell state preparation</h2> <p><img src="/assets/img/image-25.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>I‚Äôd also like for ChatGPT to plot the results:</p> <p><img src="/assets/img/image-26.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <p>Unfortunately, ChatGPT doesn‚Äôt allow me to run the code and we have some banter about arbitrary code execution:</p> <p><img src="/assets/img/image-28.png" alt="" width="75%" class="img-fluid rounded z-depth-0"/></p> <h2 id="does-chatgpt-understand-what-i-just-taught-it-about">Does ChatGPT understand what I just taught it about?</h2> <p>At this point I have described in plain English the basic principles of qubits, quantum systems, gates, entanglement, and measurement. ChatGPT has constructed code which would accurately simulate this, but does it understand what I just instructed it to build?</p> <p><img src="/assets/img/image-29.png" alt="image-29" width="75%" class="img-fluid rounded z-depth-0"/></p>]]></content><author><name></name></author><category term="physics"/><category term="ml"/><summary type="html"><![CDATA[You have probably seen some of the things that you can do with OpenAI‚Äôs new ChatGPT which was released last week: this unnervingly human-like language model can invent a fictional language, emulate a virtual machine, and debug code for you.]]></summary></entry><entry><title type="html">3D printed mirror array</title><link href="https://bencbartlett.github.io/blog/3D-printed-mirror-array/" rel="alternate" type="text/html" title="3D printed mirror array"/><published>2021-11-11T00:00:00+00:00</published><updated>2021-11-11T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/3D-printed-mirror-array</id><content type="html" xml:base="https://bencbartlett.github.io/blog/3D-printed-mirror-array/"><![CDATA[<p>I recently got engaged to the wonderful person holding the hexagonal mirror thingy in the photo below. We‚Äôre both huge nerds and I wanted to do something unique for a proposal, so I designed and 3D printed a mirror array to ask the question for me. The mirrors are angled so that just before sunset on our 8th anniversary, it reflects the light from the setting sun onto the ground to spell out ‚ÄúMARRY ME?‚Äù</p> <p><img src="/assets/img/header.jpg" alt="img" class="img-fluid rounded z-depth-0"/></p> <p>Since I had a lot of fun with this project and because I love open-source code, I figured I‚Äôd publish all the source code I wrote to generate the 3D printed model and make a writeup of how I designed this. It is straightforward to modify the code to produce a 3D-printable mirror array to project any arbitrary image onto any focal plane.</p> <p>The code for this project is at <a href="https://github.com/bencbartlett/3D-printed-mirror-array"><code class="language-plaintext highlighter-rouge">github.com/bencbartlett/3D-printed-mirror-array</code></a>.</p> <h3 id="supplies">Supplies</h3> <ul> <li>A 3D printer <ul> <li>I used a Creality Ender 3 v2 which I was reasonably happy with, but any FDM printer with a reasonable build volume should work fine.</li> </ul> </li> <li>PLA filament [<a href="https://www.amazon.com/dp/B01EKEMFQS">amazon.com/dp/B01EKEMFQS</a>]</li> <li>1-inch hexagonal mirror tiles [<a href="https://www.amazon.com/dp/B08CSCNT86">amazon.com/dp/B08CSCNT86</a>]</li> <li>Cyanoacrylate glue [<a href="https://www.amazon.com/dp/B01LYO4R4I">amazon.com/dp/B01LYO4R4I</a>] <ul> <li>It is important that you use glue that doesn‚Äôt expand when it cures or it will mess up the very sensitive mirror angles! A very thin coating of cyanoacrylate glue is sufficient to hold the mirrors in place.</li> </ul> </li> <li>Python &gt;3.6 with the following libraries installed: <code class="language-plaintext highlighter-rouge">numpy</code>, <code class="language-plaintext highlighter-rouge">numpy-stl</code>, <code class="language-plaintext highlighter-rouge">matplotlib</code>, <code class="language-plaintext highlighter-rouge">hexy</code>, <code class="language-plaintext highlighter-rouge">vpython</code> (optional if you don‚Äôt care about rendering the debug visualizations)</li> </ul> <h3 id="computing-the-mirror-angles">Computing the mirror angles</h3> <p>The basic idea here is that we have an array of mirrors forming a hexagonal grid. Each mirror is located with its centroid at some point in space, and we want for it to reflect a ray of sunlight to a pixel at some location on the ground (or any other focal plane). Since we know where each mirror is, where each corresponding target is, and where the sun is, we can solve for how each mirror needs to be oriented in 3D space in order to reflect the sunlight onto its corresponding target.</p> <p>Consider just a single mirror and a single target pixel. The center of the mirror has \((x, y, z)\) coordinates located at some vector <code class="language-plaintext highlighter-rouge">mirror_pos</code>, and the center of the target pixel is at <code class="language-plaintext highlighter-rouge">target_pos</code>. Let‚Äôs define vectors \(\vec{u}, \vec{v}\) such that \(\vec u =\)<code class="language-plaintext highlighter-rouge">mirror_pos</code> - <code class="language-plaintext highlighter-rouge">target_pos</code> is the vector pointing from the target to the mirror center, and \(\vec v = \left(\sin \phi, \cos \phi \sin \theta, \cos \phi \cos \theta\right)\) is the vector pointing in the direction of the sun (a point source placed at infinity). Here we‚Äôre assuming the sun is at an inclination of \(\theta\) from the horizon and that the azimuthal angle relative to the mirror is \(\phi\).</p> <p>Since the reflected angles are the same as the incident angles for a mirror, the normal vector \(\hat n\) of the mirror just needs to bisect these two vectors \(\vec u\) and \(\vec v\), so we have that \(\hat n = \frac{\vec v}{\|\| \vec v \|\|} - \frac{\vec u}{\|\| \vec u \|\|}\):</p> <p><img src="/assets/img/img_0274-20231121110254709.png" alt="" class="img-fluid rounded z-depth-0"/></p> <p>Now that we know how a mirror with a given location and target needs to be angled, let‚Äôs move on to generating the 3D models for the mirror frame which will hold the mirror at this point in space with this correct orientation.</p> <h3 id="generating-a-3d-model-of-a-hexagonal-prism">Generating a 3D model of a hexagonal prism</h3> <p>A 3D model is just a list of vertices and faces. The vertices are the corners of the polygon (a list of 3D coordinates) and the faces are a list of triangular facets, where each face is specified by tuple containing the indices of three vertices. So to generate the 3D model of the hexagonal prism, I just needed to compute the coordinates for the corners of the prism and define the triangular facets that form the outer faces of the prism.</p> <p>The 3D printed plastic frame of the mirror array is made up of a grid of hexagonal prisms. Each hexagonal prism has its base on the \((x,y)\) plane and has a position \(\vec p\) specified by the location of the centroid of the top face (coordinate 7 in the left image), which is normal to the vector \(\hat n\). To compute the coordinates for the top corners, I computed the intersection of the plane defined by \(\vec p, \vec n\) and the vector pointing vertically from each corner of the base (right image). I then just used a hard-coded list of vertex indices to specify the faces (so, for example, one face is <code class="language-plaintext highlighter-rouge">(0,5,6)</code>, while another is <code class="language-plaintext highlighter-rouge">(5,12,13)</code> when referring to the left image).</p> <p><img src="/assets/img/prisms.jpg" alt="prisms" class="img-fluid rounded z-depth-0"/></p> <p>Another thing I included in this function was the ability to add a mirror aligner structure to the prism. This mirror aligner is a small protrusion on two sides of the hex prism which fits on a corner of the hexagonal mirrors, which makes it much less tedious to glue hundreds of mirrors to the final structure (right image below). A subtle detail here is that the coordinates of the mirror aligner are not collinear with the coordinates of the top corners of the hex prism: the mirror aligner always needs to make a \(120^\circ\) angle, but if the hex prism has a top surface with a steep slope, the corner angles get distorted. So to compute the coordinates of the mirror aligner, I computed the projection of the x axis onto the plane of the the top of the prism as \(\hat{x}' = \hat y \times \hat n\). Then I rotated this vector about the normal vector \(\hat n\) by increments of \(2 \pi / 6\) to get the corners of the aligner.</p> <p><img src="/assets/img/aligners.jpeg" alt="aligners" class="img-fluid rounded z-depth-0"/></p> <h3 id="generating-a-hexagonal-grid-of-prisms">Generating a hexagonal grid of prisms</h3> <p>Once I had the code to generate the hex prim and the mirror aligner, it is straightforward to generate a grid of these structures, since fusing 3D models can be as simple as concatenating the lists of vertices and faces. This approach does result in some unwanted internal geometry, but most slicer software is smart enough to figure this out and ignore internal geometry when printing.</p> <p>I generated the hexagonal grid coordinates that define the center of each pillar, then I generated the list of hex prisms with the appropriate orientations to reflect onto a list of target coordinates, and finally I fused the list of prisms together into a single <code class="language-plaintext highlighter-rouge">.stl</code> file. For aesthetic reasons, I chose to separate the prism by about a 2mm gap and have them joined at the bottom by a slightly wider prism. An example 3D model of a small grid of prisms which all have a common focal point is shown below. The aligner structures are highlighted in red. (Note the difference in angles between the aligner corners and the prism top corners.)</p> <p><img src="/assets/img/screen-shot-2021-11-09-at-4.30.52-pm-20231121110255621.png" alt="" class="img-fluid rounded z-depth-0"/></p> <h3 id="optimally-matching-targets-to-mirrors">Optimally matching targets to mirrors</h3> <p>One of the more interesting problems to solve in this project was how to optimally match target light spots to corresponding mirrors to maximize the focal distance tolerance. (So that you can hold the structure at a slightly incorrect distance or orientation from the focal plane and it will still reflect a legible message.)</p> <p>The mirror array will project a set of rays onto the focal plane to form an image, and when the structure is placed at exactly the right angle and distance from the focal plane, the image will (in theory) be exactly what you want it to be. But if you deviate from this height or angle, the image will slightly deform. However, you can mitigate this by making the rays as parallel as possible, so as to minimize any times where rays will cross each other before the focal plane.</p> <p>Consider the following scenario in the figure below. There are four mirrors projecting light rays onto four targets which form a diamond formation when placed at the proper focal distance. On the left side, two of the rays will cross each other, while on the right side, the rays are closer to parallel and do not cross. If you move the focal plane relative to the mirror array, the left image will distort, becoming vertically squished, while the right image does not significantly distort (the points remain in the same relative configuration).</p> <p><img src="/assets/img/img_0279-1-20231121110254619.png" alt="" class="img-fluid rounded z-depth-0"/></p> <p>So we want to match the target points with corresponding mirrors so that the rays are as parallel as possible and minimal crossings occur. How should we do this? An early approach I took was to iterate over the mirrors and greedily assign each target to the mirror which minimizes the angle of incidence (so, minimizing the inner product of \(\vec{n} \cdot \vec{u}\)). However, this approach didn‚Äôt work as well as I had hoped because it only considered the magnitude of this inner product rather than the direction of the reflected light beam. You can see some of the distortion in the early test prints of the heart mirrors in the next section, which used this initial matching algorithm. (Although some of that distortion was also due to poor adhesion to the print bed.)</p> <p>The algorithm I ended up settling on is inspired by the structure of the hexagonal grid itself. A hexagonal grid with radius of \(R\) hexagons has a number \(n\_R = 1 + \sum\_{r=1}^R 6 \left(r-1\right)\) of mirrors. So there‚Äôs one mirror at the center (\(R=1\)), and after that, 6 mirrors in the innermost ring (\(R=2\)), 12 mirrors in the next ring, then 18, and so on. To minimize ray crossings, I computed the center of mass of the target pixel coordinates, then grouped the coordinates into bins based on their distance from the center of mass, where each bin has a size equal to the number of mirrors in that ring. So the centermost target pixel gets assigned to the center mirror, then the 6 other pixels closest to the center gets assigned to the first ring, and so on. Within each bin, I ordered the target coordinates clockwise starting from the bottom coordinate, and I assigned the target to the mirrors iterated in the same order. So the outermost ring of mirrors corresponds to the outermost ring of targets, and within this set of targets, the bottom target gets assigned to the bottom mirror, the leftmost target gets assigned to the leftmost mirror, etc., as shown in the figure below.</p> <p><img src="/assets/img/img_0280-20231121110254699.png" alt="" class="img-fluid rounded z-depth-0"/></p> <p>This matching algorithm ended up working quite well. (<a href="https://bencbartlett.wordpress.com/2018/03/28/screeps-4-hauling-is-np-hard/">And I do love matching algorithms‚Ä¶</a>) Here is a side by side comparison of the rays which form the ‚ÄúMARRY ME?‚Äù message when assigned to mirrors randomly (left) versus when assigned using this matching algorithm (right). You can see that the rays are much more parallel. This means that the mirror array can be held within a much wider tolerance of the correct distance from the focal plane while still projecting the message legibly.</p> <p><img src="/assets/img/sidebyside.jpeg" alt="sidebyside" class="img-fluid rounded z-depth-0"/></p> <p>(Also, I discovered the biggest near-failure of this project around the time I was writing the visualization code that I used to generate the images above. At that point, I was about 20 hours into printing the final mirror array frame, and I realized that what I would have printed would actually project the mirror image of what I wanted! ‚Äú?EM YRRAM‚Äù I hadn‚Äôt caught this issue previously because the test image of the heart was symmetric, so I didn‚Äôt realize that I was printing the mirror of the correct image. Fortunately I found this mistake in time, since by this point the proposal date was just a week out, so if I had caught this any later I wouldn‚Äôt have had time to print another frame. The takeaway from this near-miss is that writing visualization code to help debug what is going on is very important‚Ä¶ üôÉ)</p> <h2 id="printing-the-mirror-array-frame">Printing the mirror array frame</h2> <p>So by this point I had developed the end-to-end process where you can input a set of coordinates that form your desired image, the location of the focal plane, and the location of the sun, and you get out a <code class="language-plaintext highlighter-rouge">.stl</code> model of the mirror array frame that you can 3D print. So now we just need to print this out and glue on the mirrors ‚Äì simple, right?</p> <p><img src="/assets/img/yes_but_no-20231121110254919.gif" alt="" class="img-fluid rounded z-depth-0"/></p> <p>I printed four different attempts at a smaller-scale mirror array to test for the big thing. Each small frame had 37 mirrors and would project the design of a heart. (37 mirrors corresponds to a radius \(R=3\) hex grid, which was the largest I could print out in a single piece given my Ender3‚Äôs 220mm √ó 220mm print area.)</p> <p><img src="/assets/img/test_structures.jpg" alt="test_structures" class="img-fluid rounded z-depth-0"/></p> <p>There were two main problems I encountered when printing these test arrays. The first was warping due to the print not fully adhering to the print bed. This would cause the corners at the bottom to slightly peel up due to tension from the cooling layers, which would affect the angles of the hexagonal pillars above the warped base region and distort the projected image. I solved this problem by lowering the bed temperature and applying some hairspray to the print bed (some 3D printing <a href="https://ultradvice.com/best-hairspray-3d-printing-how-to-apply/">tribal knowledge</a>‚Ä¶), which worked like a charm.</p> <p>The second problem was how to print out a hex grid which was too big to fit within the print volume. Some slicer programs include built in tools to slice large prints into pieces, but I couldn‚Äôt use these because the planar cuts would slice through the hexagonal pillars, which would create a ridge on the top face and distort the angles of the mirrors, which need to be accurate to about \(\delta \theta \approx \tan^{-1} \left(\frac{\text{pixel width}}{\text{focal length}}\right)\) (which is a few tenths of a degree). So I created a few custom functions to input a set of pillar models and partition them into smaller printable sub-volumes which could be glue together. This way, the only seams would be at the base of the model, which wouldn‚Äôt affect the normal vectors of the mirrors.</p> <p>I played around with a couple of different partitioning schemes, but I settled on using this flower-like pattern shown below, both because I liked the way it looked, and because it provides more structural strength since there is no continuous seam across the entire structure along which the assembled object could snap in half.</p> <p><img src="/assets/img/hexflower.jpeg" alt="hexflower" class="img-fluid rounded z-depth-0"/></p> <p>The entire model took about a week to print (I used adaptive layer heights to speed things up a bit when printing the bottom and middle layers, but the top layers needed to be very fine to allow the mirrors to be mounted at exactly the right angles). I assembled the frame and used cyanoacrylate glue to bond each section of the frame at the base. (I had to slightly sand the edges of the final section to get it to fit.) The fully assembled frame is shown below.</p> <p><img src="/assets/img/frames.jpeg" alt="frames" class="img-fluid rounded z-depth-0"/></p> <p>The last step was carefully glueing all 196 mirrors to the completed frame. I found out on some of my earlier test structures that cyanoacrylate glue will produce a lot of vapors when it is curing which can deposit on the mirrors and cause them to look foggy. (They still reflect enough light to work but it looks uglier‚Ä¶) To prevent this, I had a fan running blowing air from right to left while I glued the mirrors, which I attached in a right-to-left, top-to-bottom ordering to minimize vapor exposure.</p> <p><img src="/assets/img/withmirrors-0593626.jpeg" alt="img" class="img-fluid rounded z-depth-0"/></p> <p>By the time I finished mounting all of the mirrors, it was the night before I was planning to propose, so in a nail-biting twist of fate, I didn‚Äôt actually get to test the final structure at sunset in advance. Fortunately, it worked exactly as I wanted it to! (And even more fortunately, the temperamental fog of the SF Bay Area decided to take the day off.)</p> <p>This was the first project I‚Äôve done with 3D printing (and in fact I got into 3D printing specifically to do this idea), and it felt like magic having a fabricator sitting in my bathroom that could just bring this idea into existence from nothing but a bit of code and some basic principles of physics.</p> <p>You can find all of the code I wrote to make this project at <a href="https://github.com/bencbartlett/3D-printed-mirror-array">github.com/bencbartlett/3D-printed-mirror-array</a>.</p> <p><img src="/assets/img/img_3009-20231121110256294.png" alt="" class="img-fluid rounded z-depth-0"/></p> <figure> <video src="/assets/video/mirror_h265.mp4" class="img-fluid rounded z-depth-0" width="auto" height="auto" autoplay="" controls="" loop=""/> </figure>]]></content><author><name></name></author><category term="physics"/><category term="math"/><category term="3dprinting"/><summary type="html"><![CDATA[I recently got engaged to the wonderful person holding the hexagonal mirror thingy in the photo below. We‚Äôre both huge nerds and I wanted to do something unique for a proposal, so I designed and 3D printed a mirror array to ask the question for me. The mirrors are angled so that just before sunset on our 8th anniversary, it reflects the light from the setting sun onto the ground to spell out ‚ÄúMARRY ME?‚Äù]]></summary></entry><entry><title type="html">Screeps #6: Verifiably refreshed</title><link href="https://bencbartlett.github.io/blog/screeps-6-verifiably-refreshed/" rel="alternate" type="text/html" title="Screeps #6: Verifiably refreshed"/><published>2019-01-02T00:00:00+00:00</published><updated>2019-01-02T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-6-verifiably-refreshed</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-6-verifiably-refreshed/"><![CDATA[<h2 id="assimilation-part-1-verification">Assimilation (part 1): verification</h2> <p>Over the last year, Overmind has gotten quite popular. It is now the dominant open-source bot running on the public servers, especially on <code class="language-plaintext highlighter-rouge">shard2</code>:</p> <p><img src="/assets/img/Screen-Shot-2019-01-02-at-11.34.44-AM.png" alt="" class="img-fluid rounded z-depth-0"/></p> <p>Having so many players running my script near me is a cool experience, and it gave me a thematically-fitting direction for Overmind‚Äôs final evolution: to become a true universal hivemind by assimilating other players.</p> <p><a href="https://github.com/bencbartlett/Overmind/blob/master/src/assimilation/Assimilator_obfuscated.js">Assimilation</a> is a feature I‚Äôve been teasing for a long time now. It allows all players running Overmind to act as a single, collective entity, sharing creeps and resources between each other and responding jointly to a master ledger of all directives shared by all players. When completed, (my) Overmind will truly be the <a href="https://starcraft.fandom.com/wiki/Overmind">overriding will of the Zerg swarm</a>.</p> <p>Before you get too excited, assimilation is still under construction and far from complete, but I decided to use a portion of this post to talk about an important aspect of it which has already been finished: verifying the codebase.</p> <p>Because of how tightly integrated assimilated players will be, it is possible to modify the codebase to take advantage of the system. Since the codebase is open source, one could modify it to receive resources or combat assistance but never to give them when needed. Since I didn‚Äôt want to completely obfuscate the entire codebase, I needed a way to verify the integrity of certain parts of the codebase.</p> <p>Enter the <code class="language-plaintext highlighter-rouge">Assimilator</code>.</p> <p>The Assimilator is a global, persistent object which provides a way of deciding which Overmind players can be mutually trusted. There are a variety of ways it does this, some of which I won‚Äôt mention, but I‚Äôll talk about the main verification method here.</p> <p>If you‚Äôve looked around my codebase recently, you‚Äôve probably noticed some¬†<a href="https://github.com/bencbartlett/Overmind/blob/master/src/logistics/TerminalNetwork.ts#L53">parts</a> of the script which are marked with an <a href="https://github.com/bencbartlett/Overmind/blob/master/src/assimilation/decorator.ts">@assimilationLocked</a> decorator. This decorator registers that part of the code with the Assimilator, which ensures that it has not been tampered with. To do this, it exploits a wonderful (horrible?) behavior of Javascript, which is that if <code class="language-plaintext highlighter-rouge">Foo</code> is a class, then¬†<code class="language-plaintext highlighter-rouge">''+Foo</code>¬†evaluates to a string containing the source code for <code class="language-plaintext highlighter-rouge">Foo</code> (!) :</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">baz</span><span class="dl">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">''</span> <span class="o">+</span> <span class="nx">Foo</span><span class="p">);</span>
<span class="c1">// &gt; "class Foo {\n    constructor()‚Ä¶z\";\n    }\n\n}"</span>
</code></pre></div></div> <p>The Assimilator uses this behavior to generate a checksum of the @assimilationLocked portions of the script using a <a href="https://github.com/bencbartlett/Overmind/blob/master/src/algorithms/sha256.ts">sha256</a> cryptographic hash. Whenever I deploy code to the main server, a checksum for my version of the code is generated and stored in my memory along with all unique hashes from the last 1 million ticks. If a player is assimilated, then every 1000 ticks, Overmind will send 100 energy to one of my terminals, with a hash of the current codebase as the description. If I receive a checksum which matches that of a recent valid version, I reply on the following¬†tick with a unique clearance key valid for the next 1000 ticks transmitted through public memory:</p> <p><img src="/assets/img/Screen-Shot-2019-01-02-at-12.29.43-PM.png" alt="Screen Shot 2019-01-02 at 12.29.43 PM" class="img-fluid rounded z-depth-0"/></p> <p>The assimilator looks at the master ledger of clearance codes to determine which players are trusted.¬†In the future, clearance keys will be used to generate flag names based on the tick they were created. Only flags matching the correct naming pattern will be uploaded to the master ledger of directives shared among the hivemind. This allows players to manually place their own directives which only their creeps will respond to (for fighting their own personal skirmishes), as well as for the Overmind to automatically place directives which all assimilants will see.</p> <h2 id="arefresh-ing-new-architecture">A¬†<code class="language-plaintext highlighter-rouge">refresh</code>-ing new architecture</h2> <p>Prior to some recent changes, Overmind had never been a terribly CPU-efficient bot. A major reason for this is its very hierarchical, object-oriented architecture, which heavily employs classes. Classes are expensive to instantiate, and having many classes with shared references to each other and to game objects makes garbage collection in the V8 engine more expensive than for a flatter, prototype-based architecture.</p> <p>To get a more detailed idea of why this was a problem, let‚Äôs look at Overmind‚Äôs main loop structure (which I talk about in more detail in a¬†<a href="https://bencbartlett.wordpress.com/2018/01/15/screeps-1-overlord-overload/">previous post</a>). The important bits can be divided into three main (heh) phases:</p> <ol> <li><code class="language-plaintext highlighter-rouge">build()</code>¬†Recursively instantiate all classes used by the AI. The Overmind object directly instantiates all <a href="https://github.com/bencbartlett/Overmind/blob/master/src/Colony.ts">colonies</a> and <a href="https://github.com/bencbartlett/Overmind/blob/master/src/directives/Directive.ts">directives</a>, which instantiate their <a href="https://github.com/bencbartlett/Overmind/blob/master/src/Colony.ts#L428">hive clusters</a>, <a href="https://github.com/bencbartlett/Overmind/blob/master/src/logistics/LogisticsNetwork.ts">logistics networks</a>, and <a href="https://github.com/bencbartlett/Overmind/blob/master/src/overlords/Overlord.ts">overlords</a>; overlords instantiate their <a href="https://github.com/bencbartlett/Overmind/blob/master/src/zerg/Zerg.ts">Zerg</a> (the wrapper class for creeps), and so on down the tree.</li> <li><code class="language-plaintext highlighter-rouge">init()</code>¬†Register all requests for actions to be taken this tick, such as <a href="https://github.com/bencbartlett/Overmind/blob/master/src/overlords/Overlord.ts#L310">creep spawning</a>, <a href="https://github.com/bencbartlett/Overmind/blob/master/src/hiveClusters/commandCenter.ts#L108">requesting resources</a>, or <a href="https://github.com/bencbartlett/Overmind/blob/master/src/logistics/RoadLogistics.ts">scheduling road repairs</a>.</li> <li><code class="language-plaintext highlighter-rouge">run()</code>¬†All state-changing actions happen here: creeps are directed by their overlord, the <a href="https://github.com/bencbartlett/Overmind/blob/master/src/Overseer.ts">Overseer</a> adds and removes directives to respond to the environment, <a href="https://github.com/bencbartlett/Overmind/blob/master/src/logistics/TerminalNetwork.ts">resources are distributed</a> between colonies, <a href="https://github.com/bencbartlett/Overmind/blob/master/src/logistics/TradeNetwork.ts">trades are made</a> with other players, and <a href="https://github.com/bencbartlett/Overmind/blob/master/src/intel/RoomIntel.ts">intel is gathered</a>.</li> </ol> <p>Some heavy profiling revealed that the build phase was using up almost as much CPU as the run phase (and if you include garbage collection time, possibly more)! Clearly this was not optimal‚Ä¶</p> <p>The obvious solution was to make all of the classes persistent, but I had been holding off on doing this for two reasons: (1) much of Overmind‚Äôs codebase was written before isolated-VM, so this change would be a major undertaking, and (2) I was hoping that the devs would release persistent game objects, which they had <a href="https://screeps.com/forum/topic/2307/development-updates">teased</a> back in August.¬†However, after a few months waiting for persistent game objects while ignoring the growing elephant in the CPU-constrained room, I decided to just emulate their behavior myself. My solution was to use a set of new caching methods to add a new, alternate phase to the main loop: <code class="language-plaintext highlighter-rouge">refresh()</code>.</p> <p>In the new architecture, every n-th tick (where n=20 by default), the build phase is run, completely re-instantiating all script objects. On all other ticks, refresh() is run instead, updating all references to game objects while keeping existing script class instances alive, allowing for a ‚Äúsoft update‚Äù between ticks.¬† The in-game properties are updated in-place by the <code class="language-plaintext highlighter-rouge">$</code> <a href="https://github.com/bencbartlett/Overmind/blob/master/src/caching/GlobalCache.ts">caching module</a>, which makes for easier garbage collection, and the wonderful generics type safety that TypeScript provides prevents me from doing anything stupid.</p> <p>To get a more concrete idea of how this works, let‚Äôs look at an (abridged) example for how <code class="language-plaintext highlighter-rouge">build()</code> and <code class="language-plaintext highlighter-rouge">refresh()</code> work for a hatchery:</p> <script src="https://gist.github.com/bencbartlett/e8f0e92cc8ef7f3601240eb57aaed98d.js"></script> <p>During the build phase, the constructor is called, overwriting the old hatchery object and re-defining properties for all of the structures. Particularly expensive calculations are done with the <code class="language-plaintext highlighter-rouge">$.set()</code> method, which takes a property name and a callback to compute a list of game objects; the callback results are cached to global and assigned to the specified property. During the refresh phase, these properties are updated in-place using the <code class="language-plaintext highlighter-rouge">$.refresh()</code> and <code class="language-plaintext highlighter-rouge">$.refreshRoom()</code> methods. In the global caching module, these methods look like this:</p> <script src="https://gist.github.com/bencbartlett/09406e22a7991a590d2b308f7ac6a0b7.js"></script> <p>This new cache-friendly architecture has been running on the public servers for several months now, and is included in the new <a href="https://github.com/bencbartlett/Overmind/releases">v0.5.1 release</a>. After working a few of the kinks out, I‚Äôve been very happy with its performance: the caching changes have reduced CPU cost by over 40%!</p> <h2 id="brand-advertising">Brand advertising</h2> <p>A while ago, I started rewriting the <a href="https://github.com/bencbartlett/Overmind/blob/master/src/visuals/Visualizer.ts">Visualizer</a> system for Overmind to be better looking, better organized, and to display more useful information. Here‚Äôs a screenshot of what it looks like at the moment:</p> <p><img src="/assets/img/Screen-Shot-2018-12-20-at-5.25.45-PM.png" alt="Screen-Shot-2018-12-20-at-5.25.45-PM" class="img-fluid rounded z-depth-0"/></p> <p>I generally enjoy writing visualization code, but the part I had the most fun making was efficiently rendering the Overmind logo using room visuals. If you‚Äôve read any of my non-Screeps posts, you probably know that I <a href="https://bencbartlett.wordpress.com/2017/07/11/particle-in-a-fidget-spinner/">really</a> <a href="https://bencbartlett.wordpress.com/2017/07/11/first-blog-post/">like</a> <a href="https://bencbartlett.wordpress.com/2017/07/11/how-to-mathematica-a-practical-guide/">Mathematica</a>. I made a Mathematica notebook to disassemble the logo image into color-quantized components, and used the <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Ramer-Douglas-Peuker algorithm</a> to parameterize the perimeter of each component into a form that <code class="language-plaintext highlighter-rouge">RoomVisual.poly()</code> can accept. This algorithm finds a minimum number of points necessary to outline a shape to within a specified tolerance. The (relatively) small point count means that the logo is actually quite cheap to render ‚Äì about 1-2 CPU per tick. (And of course, visuals get disabled when the bucket drops below 9000.)</p> <p>If you want to see how I did this, you can see the Mathematica notebook¬†<a href="https://bencbartlett.files.wordpress.com/2018/12/OvermindLogoManipulation.pdf" title="OvermindLogoManipulation">as a PDF</a>¬†or download the notebook source code¬†<a href="https://www.dropbox.com/s/z4ztdzxqss5opqe/OvermindLogoManipulation.nb?dl=1">here</a>.</p>]]></content><author><name></name></author><category term="screeps"/><category term="mathematica"/><summary type="html"><![CDATA[Assimilation (part 1): verification]]></summary></entry><entry><title type="html">Screeps #5: Evolution</title><link href="https://bencbartlett.github.io/blog/screeps-5-evolution/" rel="alternate" type="text/html" title="Screeps #5: Evolution"/><published>2018-08-11T00:00:00+00:00</published><updated>2018-08-11T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-5-evolution</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-5-evolution/"><![CDATA[<p>Most of my previous posts have focused on a single aspect of my bot development. This is not one of those posts.</p> <p>Over the last few months since my last post, Overmind has evolved considerably as I‚Äôve added a ton of new features to my bot (read: <a href="https://github.com/bencbartlett/Overmind/compare/v0.2.1...HEAD">22k</a> new lines of code). While none of them were individually as technically challenging or original as the <a href="https://bencbartlett.wordpress.com/2018/03/28/screeps-4-hauling-is-np-hard/">logistics system</a> to warrant their own post, I figured I‚Äôd make this post a show-and-tell session for some of the new features I‚Äôve been working on.</p> <h2 id="bunkers">Bunkers</h2> <p>The classic ‚Äúbox and flower‚Äù layout (like the one in <a href="https://bencbartlett.wordpress.com/2018/02/06/screeps-2-interior-design/">this post</a>) was designed primarily with logistics in mind. Having a physically separated ‚Äúhatchery‚Äù (spawning block) and ‚Äúcommand center‚Äù (storage block) allows for you to place the central dropoff point for resources closer to the ideal location that minimizes total path length to nearby sources without being constrained by the full bulk of the base. This design served this purpose well, but it suffered from two key defensive flaws: the tower spread reduces total tower damage at siege points, and the spawning rate can be limited by the hatchery link bandwidth.</p> <p>Enter bunkers. Bunker <a href="https://github.com/bencbartlett/Overmind/tree/master/assets/basePlanner">assets</a> have been sitting in the AI for a long time, but living next to everyone‚Äôs friendly neighborhood tiger forced me to prioritize their development one he figured out how to exploit the flaws of my previous layout. The final design went through a lot of iterations, but I‚Äôm quite happy with how it turned out. Here‚Äôs an annotated image of a fully-developed base:</p> <p><img src="/assets/img/screen-shot-2018-08-07-at-7-12-14-pm.png" alt="Screen Shot 2018-08-07 at 7.12.14 PM" class="img-fluid rounded z-depth-0"/></p> <p>Each bunker has three permanent attendants: a manager and two queens. Managers are stationary 16-CARRY 0-MOVE creeps that sit in the center of each bunker, connecting the storage, terminal, central link, and RCL8 structures.¬†Queens are general-purpose base attendants which fill and empty structures requesting any type of resource.</p> <p>Managers are relatively unchanged in bunker colonies and are run by the same overlord as in the classic layout. The most notable difference is that managers for RCL8 bunkers are immobile (a design choice enabled by some <a href="https://github.com/bencbartlett/Overmind/blob/0ced04b501a74215124c1db2773a379563e8fa6f/src/hiveClusters/hatchery.ts#L205">improvements</a> to my creep spawning code), spending their entire life at the central ‚Äúanchor‚Äù tile of the bunker. If there are ramparts within range 3 of the anchor below their target hits, the manager will be spawned with 32 WORK parts and will fortify the ramparts when it is idling.</p> <p>Although they share the same role name as the hatchery attendants in the classic layout, queens are run by a <a href="https://github.com/bencbartlett/Overmind/blob/master/src/overlords/core/queen_bunker.ts">separate overlord</a> in bunker-type colonies, which features a large number of hard-coded optimizations specific to the bunker layout. Each ‚Äúquadrant‚Äù (group of contiguous buildings) in the bunker has a <a href="https://github.com/bencbartlett/Overmind/blob/fcc299ad7f503716fa7e5dc786ae04c01ab799ab/src/roomPlanner/layouts/bunker.ts#L501">hard-coded fill order</a>¬†(illustrated in the above image) to minimize walking distance, and each queen gets assigned two quadrants and a ‚Äúbattery‚Äù (the top and bottom containers in the bunker, which serve as an energy buffer). To further reduce the CPU cost, rather than executing the fill logic after every transfer, queens are assigned a single <a href="https://github.com/bencbartlett/Overmind/blob/0ced04b501a74215124c1db2773a379563e8fa6f/src/tasks/Tasks.ts#L31">chained</a> task object which represents <a href="https://github.com/bencbartlett/Overmind/blob/90d05e8d16261ac371af8c3622331a6797c7dd9c/src/overlords/core/queen_bunker.ts#L105">an entire ‚Äúmanifest‚Äù</a> of supply operations which can be done with the creep‚Äôs carry capacity. (The chained task also sets the¬†<a href="https://github.com/bencbartlett/Overmind/blob/0ced04b501a74215124c1db2773a379563e8fa6f/src/tasks/Task.ts#L219"><code class="language-plaintext highlighter-rouge">nextPos</code></a>¬†property of each subtask to ensure that the queen promptly moves to her next destination so no ticks are wasted idling between tasks.)</p> <p>The task-chaining logic and the generality of the logistics system makes handling requests for multiple resources in a single carry quite straightforward. So in bunker-type colonies, queens are double-purposed as lab attendants (a job handled by the manager in the classic layout). A nice feature of my bunker layout is that every spawn has a lab adjacent to it, meaning that¬†<em>creeps can be boosted while they are still spawning!</em> This helps to reduce congestion within the base and maximizes the boosted lifetime of the creeps.</p> <p>Another quirk of my new layout is that at RCL8, only 51 of the available 60 extensions are built in the main bunker. Having only 51 extensions significantly improves the compactness of the design while still allowing for one exit on each side. The remaining extensions will be placed next to ‚Äúdropoff‚Äù links in the room (links not claimed by a miningSite or upgradeSite) and will be filled by idle transporters. In the event of a siege where the links and external extensions could easily be destroyed, 51 extensions poses almost no limitation to the types of defensive creeps which can be spawned, as the colony could still spawn the most expensive healer creeps with 38-HEAL, 12-MOVE bodies.</p> <h2 id="traffic-management">Traffic management</h2> <p>If bunkers‚Äô greatest strength is the high tower damage resulting from their compactness, their greatest weakness is the congestion resulting from their compactness. Making bunkers work required some massive improvement to my traffic management code and resulted in a completely new¬†<a href="https://github.com/bencbartlett/Overmind/blob/0ced04b501a74215124c1db2773a379563e8fa6f/src/movement/Movement.ts">movement library</a>. (Previously, I used <a href="https://github.com/bonzaiferroni/Traveler">Traveler</a>; my new library uses some of the same code under the hood but adds a number of new features and integrates more tightly with the Overmind framework.)</p> <p>All creeps in my AI now have a role-dependent <a href="https://github.com/bencbartlett/Overmind/blob/master/src/movement/Movement.ts#L32">movement priority</a>, and they will push slower or blocking creeps with lesser move priority out of their way. In general, this results in the two creeps switching locations, but if the blocking creep is performing a task (such as a worker blocking a pathway while sitting in the base fortifying a rampart), it will try to move to a position that is out of the way and still in range of its task target. This allows for some pretty cool behavior like this:</p> <figure> <video src="/assets/video/TrafficManager2_h265.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" autoplay="" controls="" loop=""/> </figure> <p>Even if creeps are able to fluidly move past each other, another complication with bunkers is that groups of creeps clogging the alleyways can result in baby creeps being unable to exit their spawns. This is a particularly pronounced issue with my design, as each spawn has only two exit tiles. To solve this, I implemented a <a href="https://github.com/bencbartlett/Overmind/blob/0ced04b501a74215124c1db2773a379563e8fa6f/src/movement/Movement.ts#L337"><code class="language-plaintext highlighter-rouge">vacatePos</code></a> method which recursively pushes creeps down alleyways and blocks further movement attempts for that tick to vacate the target position.</p> <h2 id="exceptional-terminal-logic">‚ÄúExceptional‚Äù terminal logic</h2> <p>Switching base layouts across most of my colonies without evacuating energy and minerals prior to demolition would mean a lot of wasted resources! Fortunately, my terminal network has improved a lot over the last few months, and introducing terminal ‚Äú<a href="https://github.com/bencbartlett/Overmind/blob/34c1e66b98be9666fe5680e2023ccbefb935fb9c/src/logistics/TerminalNetwork.ts#L339">exception states</a>‚Äù to my terminal network was a nice solution to this problem.</p> <p>If everything is functioning normally, the terminal network works by equalizing resource amounts for energy and base minerals between rooms. On top of this, terminals can request resources from the network for boosting or lab production. The highest priority treatment are reserved for terminals which are in exception states. If a terminal is in an exception state (determined by the presence of an <a href="https://github.com/bencbartlett/Overmind/tree/master/src/directives/logistics">appropriate directive</a>¬†at the terminal position), it is removed from the list of terminals which undergo normal operation and is given priority treatment, evacuating and/or requesting resources in decreasing order of value.</p> <p>Exception states have proven to be pretty handy for a variety of uses: the¬†<a href="https://github.com/bencbartlett/Overmind/blob/master/src/directives/logistics/terminalState_emergency.ts">emergency state</a>¬†maintains a constant supply of energy and T3 boosts to fight off enemies during a siege; the¬†<a href="https://github.com/bencbartlett/Overmind/blob/master/src/directives/logistics/terminalState_rebuild.ts">rebuild state</a>¬†evacuates all minerals and keeps a small constant energy supply behind while a room is rebuilding itself; and the <a href="https://github.com/bencbartlett/Overmind/blob/master/src/directives/logistics/terminalState_evacuate.ts">evacuate state</a>¬†is triggered when a room is about to fall after a failed defense, evacuating all resources from the room to prevent them from falling into enemy hands.</p> <h2 id="we-require-more-minerals">We require more minerals!</h2> <p>Overmind <a href="https://github.com/bencbartlett/Overmind/releases/tag/v0.4.0">v0.4</a> finally added long-overdue fully automatic mineral mining, processing, trading, and boosting capabilities. Colonies now automatically start mining minerals once at RCL6. Minerals are transferred between colonies as needed for resource production. Excess minerals are sold on the market, and once a player reaches a credit threshold, missing base minerals required for resource production are purchased from the market. Labs (managed by the <a href="https://github.com/bencbartlett/Overmind/blob/90d05e8d16261ac371af8c3622331a6797c7dd9c/src/hiveClusters/evolutionChamber.ts"><code class="language-plaintext highlighter-rouge">EvolutionChamber</code></a>¬†object) automatically cycle through reaction queues to build up a stockpile of prioritized resources. Reaction cycles are planned by the¬†<code class="language-plaintext highlighter-rouge">Colony.abathur</code>¬†object, which¬†<a href="https://github.com/bencbartlett/Overmind/blob/34c1e66b98be9666fe5680e2023ccbefb935fb9c/src/resources/Abathur.ts#L172">recursively generates needed reaction queues</a> to produce the highest priority needed compound. When creeps request to get boosted, the necessary resources are transferred to the appropriate colony automatically, or, if the player has sufficient credits, they are be bought on the market if not present.</p> <h2 id="a-skynet-wannabe">A Skynet-wannabe</h2> <p>Overmind <a href="https://github.com/bencbartlett/Overmind/releases/tag/v0.5.0">v0.5</a> is the first release capable of fully automatic operation! One of the biggest challenges in achieving this milestone was figuring out a system to determine approximately optimal base layouts. Fortunately, making the switch to bunkers simplified this process considerably.</p> <p>There are three new modules which facilitate this process. The¬†<a href="https://github.com/bencbartlett/Overmind/blob/c32e360ccbead3b4d4500fdc941f6b8a9297ee92/src/roomPlanner/BasePlanner.ts"><code class="language-plaintext highlighter-rouge">BasePlanner</code></a>¬†analyzes a room to figure out if and where a bunker can be placed. If there are many possible ‚Äúanchor‚Äù positions, small sample is randomly chosen, and the position with the minimum total path length to points of interest within the room (sources and controller) is returned. The¬†<a href="https://github.com/bencbartlett/Overmind/blob/c32e360ccbead3b4d4500fdc941f6b8a9297ee92/src/strategy/ExpansionPlanner.ts"><code class="language-plaintext highlighter-rouge">ExpansionPlanner</code></a>¬†looks at a room and a given anchor position (from BasePlanner) and determines a score (roughly, energy per tick) for the room and possible nearby mining outposts. Periodically, the scores for a room are re-computed by the <a href="https://github.com/bencbartlett/Overmind/blob/90d05e8d16261ac371af8c3622331a6797c7dd9c/src/intel/RoomIntel.ts#L1"><code class="language-plaintext highlighter-rouge">RoomIntel</code></a> module, and the best score to-date and corresponding anchor position is recorded in the room memory. Over time, this results in a semi-optimal choice of bunker placement. Finally, the new¬†<a href="https://github.com/bencbartlett/Overmind/blob/c32e360ccbead3b4d4500fdc941f6b8a9297ee92/src/strategy/Strategist.ts"><code class="language-plaintext highlighter-rouge">Strategist</code></a>¬†module looks at possible rooms to colonize and chooses the one with the highest score, as long as it is not too close or too far from another colony. (Eventually, the Strategist will be responsible for other high-level decision making, but for now it only does room expansion.)</p> <p>Of course, this system is still quite new and has many improvements that can be made to it, but (even rudimentary) full autonomy a big milestone in the development of my bot.</p> <h2 id="lets-end-on-a-cliffhanger">Let‚Äôs end on a cliffhanger</h2> <p>In a previous <a href="https://bencbartlett.wordpress.com/2018/03/12/screeps-3-state-of-the-automated-union/">blog post</a>, I talked about the remaining boxes I wanted to check off before releasing version 1.0 of my bot. At this point, the boxes are all checked (with checkmarks of various messiness), and <strong>the next release will be Overmind v1.0</strong>.</p> <p>So what happens now? Well, there are three major things I want to polish before release.</p> <p>First, I need to restructure parts of the AI to be more CPU efficient. I am currently fairly limited by CPU, as I have been holding out on making some much needed improvements for the devs to release persistent game objects. I‚Äôll likely hold out until the <a href="https://screeps.com/forum/topic/2307/development-updates">promised PTR content</a> in late August, but if persistent game objects aren‚Äôt included, I‚Äôll start to develop an emulator for them myself.</p> <p>Second, I want to write proper military code. I do have passable defense and offense code in place already, but my combat code has always lagged behind my economics code. I‚Äôve added a lot of the framework for fully automatic combat over the last few months, including <a href="https://github.com/bencbartlett/Overmind/blob/90d05e8d16261ac371af8c3622331a6797c7dd9c/src/logistics/SpawnGroup.ts">distributed spawning</a> and <a href="https://github.com/bencbartlett/Overmind/blob/90d05e8d16261ac371af8c3622331a6797c7dd9c/src/movement/Movement.ts#L561">combat movement</a>, but I have yet to properly plug it all in.</p> <p>Finally, I have something special that will define the 1.0 release. (You might have heard about it already in the <a href="https://screeps.slack.com/messages/overmind">#overmind</a> Slack channel.) I won‚Äôt spoil the surprise yet, but in the words of my favorite Westworld character, ‚ÄúIt‚Äôs something I‚Äôve been working on for quite some time‚Ä¶ Something quite original.‚Äù</p>]]></content><author><name></name></author><category term="screeps"/><summary type="html"><![CDATA[Most of my previous posts have focused on a single aspect of my bot development. This is not one of those posts.]]></summary></entry><entry><title type="html">Screeps #4: Hauling is (NP-)hard</title><link href="https://bencbartlett.github.io/blog/screeps-4-hauling-is-np-hard/" rel="alternate" type="text/html" title="Screeps #4: Hauling is (NP-)hard"/><published>2018-03-28T00:00:00+00:00</published><updated>2018-03-28T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-4-hauling-is-np-hard</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-4-hauling-is-np-hard/"><![CDATA[<p>Logistics - the problem of efficiently transporting resources - is one of the most interesting and deepest problems in Screeps. (And it‚Äôs probably the single part of the game I‚Äôve spent the most time thinking about.)</p> <p><img src="/assets/img/designated_drivers.png" alt="" class="img-fluid rounded z-depth-0"/></p> <p>In this post, I‚Äôm going to talk about the overhauled logistics system I‚Äôve spent the last few months working on. Since this post is really long (but I hope it‚Äôs worth the read!), I‚Äôve divided it up into three parts:</p> <ul> <li>In <a href="#part1">Part 1</a>, I‚Äôll talk about the advantages and disadvantages of my old system and why it motivated an overhauled logistics system.</li> <li>In <a href="#part2">Part 2</a>, I present a generalization of the ‚Äúcreep routing problem‚Äù, discuss why finding an exact solution is infeasible and motivate my approach in finding an approximate solution to the problem.</li> <li>Finally, in <a href="#part3">Part 3</a>, I‚Äôll give a detailed explanation of how my new logistics system works.</li> </ul> <hr/> <h1 id="part-1-feeling-boxed-in">Part 1: Feeling ‚ÄúBoxed-in‚Äù</h1> <p><a href="https://github.com/bencbartlett/Overmind/blob/4b234396ee9cf44bdc57de3551e4e7cea05e9027/src/logistics/TransportRequestGroup.ts"><code class="language-plaintext highlighter-rouge">TransportRequestGroups</code></a> (which existed in my old AI, but which I cleaned up in the <a href="https://bencbartlett.wordpress.com/2018/01/15/screeps-1-overlord-overload/">Overlord Overload rewrite</a>) act as a ‚Äúbox‚Äù to group prioritized resource requests. For example, each colony has a request group which suppliers attend to. At early levels, the hatchery puts requests into that group, but at RCL4+, the hatchery gets its own dedicated attendant (the queen) and its own request group.</p> <p>This way of compartmentalizing requests proved to be quite useful in some cases, giving the convenience of ‚Äúthrow it all in a box‚Äù while still allowing me to specify which creeps do what. However, this system did not provide much in the way of flexibility. Isolating requests to separate boxes makes it difficult to handle more complex requests which need require multiple transportation ‚Äúlegs‚Äù, such as moving minerals to a terminal, sending them to another terminal, then transferring them from the terminal to a lab.</p> <h2 id="greed-is-good-sometimes">Greed is good‚Ä¶ sometimes.</h2> <p>My old transport system took a greedy approach which was simple but inflexible, needlessly separating creep roles which could be combined. <a href="https://github.com/bencbartlett/Overmind/blob/4b234396ee9cf44bdc57de3551e4e7cea05e9027/src/overlords/core/overlord_haul.ts">Haulers</a> bring in energy from remote sources and put them in a dropoff structure and <a href="https://github.com/bencbartlett/Overmind/blob/4b234396ee9cf44bdc57de3551e4e7cea05e9027/src/overlords/core/overlord_supply.ts">suppliers</a> take energy from storage and distribute it throughout a room. (There are also 1mineralSuppliers1 and queens which have slightly-modified supplier logic.) This is basically how they worked in pseudocode:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function haulerLogic(hauler):
  if hauler has a task:
    execute the task
  else:
    if hauler has energy:
      hauler.task = transfer energy to dropoff structure
    else:
      let target = highest priority unhandled request
      hauler.task = withdraw energy from target
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function supplierLogic(supplier):
  if supplier has a task:
    execute the task
  else:
    if supplier has energy:
      let target = closest high-priority unhandled request
      supplier.task = transfer energy to target
    else:
      supplier.task = obtain energy from store structure
</code></pre></div></div> <p>In the simplest case, the dropoff structure is only ever colony.storage, and this approach actually works decently well. However, things get hairy when you add multiple possible dropoff locations, such as when you build several dropoff links in a room.</p> <p>Suppose you own a room that harvests from its left and right neighbors, so you put links on the left and right sides of the room, with the storage in the middle. A hauler could come in from the left, deposit to the left link, then start handling a request from the right room, walking past the storage and negating the usefulness of the link.</p> <p>To solve this problem, I introduced the idea of <a href="https://github.com/bencbartlett/Overmind/blob/4b234396ee9cf44bdc57de3551e4e7cea05e9027/src/hiveClusters/hiveCluster_miningGroup.ts"><code class="language-plaintext highlighter-rouge">miningGroup</code></a>s a while back. Mining groups bundle together mining sites by a common dropoff location, and each mining group has its own TransportRequestGroup and separate fleet of haulers. This prevents haulers from wasting precious CPU time wandering across rooms, but does cause problems of its own. Since it is CPU-efficient to always make the largest haulers possible to minimize per-tick fixed CPU cost, splitting a colony‚Äôs mining sites into several groups means that the expected hauler overhead (e.g. spawning 6 haulers when only 5.2 are needed) gets multiplied by the number of groups.</p> <p>Additionally, this system is pretty inflexible. Haulers and suppliers have the exact same body layout, so they could be combined into one class, but the rigid rules-based structure of mining groups and request groups made it difficult to combine the roles. Having separate roles for resource influx and outflux also made it difficult to fulfill more dynamic requests, such as a worker who is fortifying a wall asking for an energy refill from a nearby hauler.</p> <p>In redesigning my logistic system, I wanted to make a system with only one transport role which could flexibly and quickly respond to requests as they appeared. Making such a general-purpose system would require something more nuanced than a straightforward rules-based decision tree, so I spent a lot of time considering generalized versions of this problem.</p> <h1 id="part-2-the-creep-routing-problem">Part 2: The Creep Routing Problem</h1> <p>(Disclaimer: this part contains a lot of math and isn‚Äôt really necessary to understand how the new logistics system works, so feel free to skip it and move to <a href="#part3">the next section</a> if you get bored.)</p> <p>The problem of optimally transporting resources around a room with a fleet of creeps is very similar to a well-studied NP-hard problem in combinatorial optimization called the vehicle routing problem (VRP), which is an extension of the famous traveling salesman problem. There are many variations of the VRP, but the most similar one to this problem is the vehicle routing problem with pickup and delivery (VRPPD), which seeks minimize a cost function for a fleet of vehicles which must visit pickup and dropoff locations. I‚Äôll discuss a formalized version of the ‚Äúcreep routing problem‚Äù below, closely following the treatment of the VRPPD in [1].</p> <p>Let \(G_{room}=(V_{room},E_{room})\) be an undirected graph representing the configuration of a Room, with vertices \(V_{room}\) corresponding to RoomPositions and edges \(E_{room}\) connecting any two adjacent RoomPositions which a creep can traverse.</p> <p>Conceptually, a ‚Äúrequest‚Äù is a resource that needs to be moved from one location to another, such as moving energy from a remote container into storage. Let \(R(t)=\{r_{i}\}\) be the set of requests at time \(t\), where each request is a tuple \(r_{i}=(o_{i},\{d_{j}\}_{i},q_{i})\) with origin \(o_{i}\), set of possible destinations \(\{d_{j}\}_{i}\) and capacity \(q_{i}\).</p> <p>(This is a slight departure from the VRPPD: since all energy is the same, it can have multiple possible dropoff locations. For simplification, and to better adhere to [1], we denote all \(\{d_{j}\}\) as unique: that is, if a destination \(d_{1}=d_{2}\) is shared by two separate requests \(r_{1}\) and \(r_{2}\), we still treat \(d_{1},d_{2}\) as unique, such that a creep visiting this position can count as visiting \(d_{1},d_{2}\), or both. This is to simplify conditions 2 and 3, listed below.)</p> <p>Denote the set of all origin nodes by \(O=\bigcup_{i}o_{i}\) and all destination nodes by \(D=\bigcup_{i,j}d_{ji}\). Let \(V=O\cup D\), and for each pair of distinct vertices \(v_{i}\neq v_{j}\in V\), let \(e_{ij}\) be an edge connecting them with weight \(w_{ij}\) (defined as the number of ticks it takes a hauler to travel from \(v_{i}\) to \(v_{j}\)). Let \(E=\bigcup_{i,j}e_{ij}\) and \(W=\bigcup_{i,j}w_{ij}\) and let \(G(t)=(V,E,W)\) be the complete undirected graph. Let \(C=\{c_{i}\}\) be the set of transporter creeps, where \(c_{i}=(p_{i},q_{i})\) with position \(p_{i}\in V_{room}\) and carry load \(q_{i}\le q_{max}\) for each creep.</p> <p>A pickup and delivery route \(\mathcal{R}_{k}\) for creep \(c_{k}\) is a directed route through a subset \(V_{k}\subseteq V\subseteq V_{room}\) such that:</p> <ol> <li>\((\{o_{i}\}\cup\{d_{j}\}_{i})\cap V_{k}=\emptyset\) or \((\{o_{i}\}\cup\{d_{j}\}_{i})\cap V_{k}=\{o_{i}\}\cup\{d_{l}\}_{i}\) for all \(i,j\) and for at least one \(l\): creeps picking up from a request‚Äôs origin must drop off at one of the viable destinations</li> <li>If \(\{o_{i}\}\cup\{d_{j}\}_{i}\subseteq V_{k}\), then \(o_{i}\) is visited before any \(d_{i}\): creeps dropping off at a possible location \(d_{i}\) must have picked up their load from \(o_{i}\) first.</li> <li>\(c_{k}\) visits each location in \(V_{k}\) exactly once.</li> <li>The carried load is \(q_{k}\le q_{max}\) at all times.</li> </ol> <p>A pickup and delivery plan is a set of routes \(\mathcal{P}=\{\mathcal{R}_{k}\}\) such that \(\{V_{k}\|k\}\) is a partition of \(V\). Let \(f(\mathcal{P})=\sum_{k}\sum_{j}\mathcal{R}_{k}w_{j,j-1}\) be the total cost of plan \(\mathcal{P}\) (defined in this case as the total amount of CPU it takes to execute the plan). Finally, the problem we want to solve is to find:</p> \[\displaystyle \min_{n}\{f(\mathcal{P}_{n})\},\] <p>where \(\{\mathcal{P}_{n}\}\) is the set of all possible routing plans.</p> <h2 id="definitely-not-np-easy">Definitely not NP-easy</h2> <p>Of course, even for small numbers of requests, this problem is intractable. At its core, finding an exact solution to this problem still boils down to solving multiple partitionings of the traveling salesman problem, which scales as \(\mathcal{O}(n^{2}2^{n})\) even using smart dynamic programming approaches.</p> <p>Several papers have demonstrated clever exact solutions to VRPPD, such as [2], which used a branch-and-bound approach to find optimal routings for similar vehicle and requester numbers to what you could expect for a mid-size colony, but these typically took tens to hundreds of seconds to compute with a C++ implementation. (Certainly not friendly to your CPU bucket!) Clearly, an exact solution is not feasible. (And even if it was, the creep routing problem is a <em>dynamic</em> problem, so the solution could change every time a new request enters or exits the picture.) So, an approximate solution is needed!</p> <h2 id="an-approximate-solution">An approximate solution</h2> <p>Finding an exact solution to the creep routing problem seeks to find a global minimum of CPU cost over all plans, so a decent place to start when looking for an approximate solution is finding a minimum of CPU cost for each individual creep over all ‚Äúpartial routing plans‚Äù: each creep does what will instantaneously maximize \(dq/dt\), where \(q\) is amount of resource transported and \(t\) is time in ticks. However, this basically boils down to the greedy approach unless we add some nuances to allow coordination between creeps.</p> <p>A few months ago, I stumbled across a paper [3] which investigated the feasibility of dynamic taxi dispatching (think Uber or Lyft) with a stable marriage assignment algorithm.</p> <p>In case it‚Äôs been a while since your last algorithms class, the stable marriage problem seeks to find a ‚Äúsymmetrically greedy match‚Äù, or ‚Äústable match‚Äù (like the one shown above) between two groups based on preferences. To use the classic (albeit somewhat heteronormative) analogy, suppose you have a group of \(M\) men and a group of \(W\) women and that each person ranks the members of the opposite group by preference. A stable match is a one-to-one pairing of \(\min(M,W)\) men to women such that there is no man-woman pair who would both rather have each other than their current partner. Here‚Äôs a simple example of a stable matching:</p> <p><img src="/assets/img/stablematching1.png" alt="StableMatching" class="img-fluid rounded z-depth-0"/></p> <p>It‚Äôs not too much of a stretch to replace ‚Äúmen‚Äù with ‚Äútransporters‚Äù and ‚Äúwomen‚Äù with ‚Äúresource requests‚Äù, and stable matchings are easy to compute - Gale-Shapley runs in \(\mathcal{O}(n^{2})\) - so this approach got me excited. I started coding my logistics system based on this principle, but as always, the devil is in the details‚Ä¶</p> <hr/> <h1 id="part-3-the-logistics-system">Part 3: The Logistics System</h1> <p>There are two entities in my new logistics system: requests and transporters. Request are submitted for targets that need a resource supplied or withdrawn (containers, towers, other creeps, <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/directives/logistics/directive_logisticsRequest.ts">even flags where resources are dropped</a>), and transporters are resource-moving creeps. At its core, the new system works by trying to symmetrically maximize resource transport rate \(dq/dt\) for both transporters and requests: each transporter \(T\) ranks requests \(R_j\) they can respond to by \(\frac{dq}{dt}\|_{T,R_j}\), and each request \(R\) ranks transporters \(T_i\) that could respond to the request by \(\frac{dq}{dt}\|_{T_i,R}\). A <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/algorithms/galeShapley.ts">stable matching is generated via Gale-Shapley</a> to assign transporters to requesters.</p> <h2 id="computing-resource-transport-rate">Computing resource transport rate</h2> <p>As you might imagine, calculating \(\frac{dq}{dt}\|_{T_i,R_j}\) is a bit more involved than simply taking (change in resource) / (distance from transporter to request). When requesters submit a request with <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts#L135">LogisticsGroup.request()</a> or a withdrawal request with <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts#L162">LogisticsGroup.provide()</a>, several values are logged in a request object:</p> <ul> <li><code class="language-plaintext highlighter-rouge">target</code>: the object that needs resources in/out</li> <li><code class="language-plaintext highlighter-rouge">resourceType</code>: the type of resource requested</li> <li><code class="language-plaintext highlighter-rouge">amount</code>: the current amount of resources that need to be moved; positive for request() and negative for provide()</li> <li><code class="language-plaintext highlighter-rouge">dAmountdt</code>: the approximate rate at which resources accumulate in the target (this is used to adjust the effective request amount based on the distance of each transporter)</li> <li><code class="language-plaintext highlighter-rouge">multiplier</code>: an optional factor to multiply effective resources transported to prioritize certain requests</li> <li><code class="language-plaintext highlighter-rouge">id</code>: a string identifier for the request; used for matching purposes</li> </ul> <p>To calculate \(\frac{dq}{dt}\|_{T_i,R_j}\), we need to consider multiple possibilities of what to visit on the way to fulfilling the request. For example, an empty transporter going directly to provide resources to an upgradeSite container would have \(dq/dt = 0\), but if it stopped by a ‚Äúbuffer structure‚Äù on the way, like storage or a link, it could have a large \(dq/dt\). So \(\frac{dq}{dt}\|_{T_i,R_j}\) gets defined as the maximum resource change per total trip time over all possible buffer structures \(B_k\) that the transporter can visit on the way:</p> \[\frac{dq}{dt}\|_{T_i,R_j}= \max_k \frac{\Delta q_k}{d_{T_i, B_k} + d_{B_k, R_j}},\] <p>where \(\Delta q_k\) is the maximum of (resources/ or capacity in transporter, |request amount|, buffer resource or capacity) and \(B_0\) is defined to be the target, i.e. going directly there without stopping by a buffer on the way. If the transporter is matched to the target, its task is forked to visit the optimal buffer first. This logic is implemented in <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts#L295"><code class="language-plaintext highlighter-rouge">LogisticsGroup.bufferChoices()</code></a>.</p> <p>When calculating \(\Delta q_k\) and \(d_{T_i, B_k}\), the logistics system needs to compensate for what the transporter and other transporters are doing. To compute \(\Delta q_k\), <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts#L253"><code class="language-plaintext highlighter-rouge">predictedAmount()</code></a> adjusts the effective amount for expected resource influx/outflux from the other transporters currently targeting the request target. (The state of the carry at the end of the transporter‚Äôs task is calculated with <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts#L274"><code class="language-plaintext highlighter-rouge">predictedCarry()</code></a>.) To compute the effective distance \(d_{T_i, B_k}\), <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts#L189"><code class="language-plaintext highlighter-rouge">nextAvailability()</code></a> returns when a transporter will next be available and where it is expected to be. (My new <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/tasks/Task.ts#L138">task manifests</a> were helpful here.) To better illustrate what these functions do, here is one of my colonies (click <a href="https://bencbartlett.files.wordpress.com/2018/03/colonyexampleannotated.png">this</a> for a higher resolution version):</p> <p><img src="/assets/img/colonyexampleannotated.png" alt="ColonyExampleAnnotated" class="img-fluid rounded z-depth-0"/></p> <p>Referencing the image above, even if \(R_1\) is nearly empty, <code class="language-plaintext highlighter-rouge">predictedAmount(R1,T1)</code> can be large because it is far away and there is nothing targeting it. However, <code class="language-plaintext highlighter-rouge">predictedAmount(R5,T1)</code> would be close to zero because \(T_4\) is targeting \(R_5\). If we wanted the next availability and carry state of \(T_3\) when it finishes what it‚Äôs doing, <code class="language-plaintext highlighter-rouge">nextAvailability(T3) = [11,upgradingContainer.pos]</code> and <code class="language-plaintext highlighter-rouge">predictedCarry(T3) = {energy: 0}</code>.</p> <h2 id="putting-it-all-together">Putting it all together</h2> <p>Finally, as pseudocode, here is a stripped down version of my new transporter logic. This is shown only for the <code class="language-plaintext highlighter-rouge">request()</code> case - <code class="language-plaintext highlighter-rouge">provide()</code> is similar but slightly different - and <code class="language-plaintext highlighter-rouge">predictedAmount()</code>, <code class="language-plaintext highlighter-rouge">predictedCarry()</code>, <code class="language-plaintext highlighter-rouge">nextAvailability()</code> aren‚Äôt shown, but they do what they sound like. (See <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/overlords/core/overlord_transport.ts">TransportOverlord.ts</a> and <a href="https://github.com/bencbartlett/Overmind/blob/55942b0db80568379394926b34bcdc2dd36b9736/src/logistics/LogisticsGroup.ts">LogisticsGroup.ts</a> for the complete code.)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function transporterLogic(transporter):
  if transporter has a task:
    execute the task
  else:
    transporter.task = getTask(transporter)

function getTask(transporter):
  let assignment = LogisticsGroup.matching()\[transporter\]

function LogisticsGroup.matching():
  let tPrefs, rPrefs = {}
  for each transporter:
    tPrefs\[transport\] = sort requests by dqdt(transport, request)
  for each request:
    rPrefs\[request\] = sort transporters by dqdt(transport, request)
  let matching = stable matching from GaleShapley(tPrefs, rPrefs)
  return matching // keys: transporters, values: assigned requests

function dqdt(transporter, request):
  // only shown for request() case, provide() is slightly different
  let amount = predictedAmount(transporter, request)
  let carry = predictedCarry(transporter)
  let \[ticksUntilFree, newPos\] = nextAvailability(transporter)
  let choices = \[\] // objects containing dq, dt, target
  choices.push({
    dq: min(amount, carry\[resourceType\]),
    dt: ticksUntilFree + distance(newPos, request.target),
    target: request.target
  })
  for each buffer:
    choices.push({
      dq: min(amount, transporter.carryCapacity, 
              buffer.store\[resourceType\]),
      dt: ticksUntilFree + distance(newPos, buffer) 
            + distance(buffer, requesttarget),
      target: buffer
    })
  return choice with best dq/dt
</code></pre></div></div> <p>I deployed this system to the public servers last week, and so far it‚Äôs been working really well. I seem to be using about 30% fewer creeps than my previous system used, and the total CPU impact is virtually unchanged (although it can be a little spikier on ticks where lots of colonies need to compute matchings at once). Overall, I‚Äôm really happy with how my new logistics system turned out!</p> <hr/> <h1 id="references">References</h1> <p><a href="http://dis.unal.edu.co/~gjhernandezp/TOS/ROUTING/Savelsbergh_1995_The_General_Pickup_and_Delivery_Problem.pdf">[1] Savelsbergh, M. W., &amp; Sol, M. (1995). The general pickup and delivery problem. <em>Transportation science</em>, <em>29</em>(1), 17-29.</a></p> <p><a href="http://www-bcf.usc.edu/~maged/publications/MultiplePickup.pdf">[2] Lu, Q., &amp; Dessouky, M. (2004). An exact algorithm for the multiple vehicle pickup and delivery problem. <em>Transportation Science</em>, <em>38</em>(4), 503-514.</a></p> <p><a href="https://www.sciencedirect.com/science/article/pii/S1877050916301351">[3] K√ºmmel, M., Busch, F., &amp; Wang, D. Z. (2016). Taxi dispatching and stable marriage. <em>Procedia Computer Science</em>, <em>83</em>, 163-170.</a></p>]]></content><author><name></name></author><category term="screeps"/><summary type="html"><![CDATA[Logistics - the problem of efficiently transporting resources - is one of the most interesting and deepest problems in Screeps. (And it‚Äôs probably the single part of the game I‚Äôve spent the most time thinking about.)]]></summary></entry><entry><title type="html">Screeps #3: State of the Automated Union</title><link href="https://bencbartlett.github.io/blog/screeps-3-state-of-the-automated-union/" rel="alternate" type="text/html" title="Screeps #3: State of the Automated Union"/><published>2018-03-12T00:00:00+00:00</published><updated>2018-03-12T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-3-state-of-the-automated-union</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-3-state-of-the-automated-union/"><![CDATA[<p><em>This will be a relatively short post. I was originally planning on the main topic of this post to be my overhauled logistics system, but I have a¬†<strong>lot</strong> to say about that. It‚Äôs easily one of the coolest things I‚Äôve implemented in Screeps, so I‚Äôm giving it its own dedicated post - expect to hear from me again later this week!</em></p> <p>My respawn to shard2 has been really good for my expansion ranking. The faster tick times combined with my much more efficient AI have pushed me up the leaderboard from #322 in January to #67 currently, and rising. Thanks to my new colonization directives, I was able to claim about 1-2 new rooms per day once my first room reached RCL4, and once it reached RCL7, it was able to switch to incubation directives to kickstart new colonies even faster.</p> <p>Here‚Äôs a timelapse of one of my rooms getting set up. (Currently, walls and ramparts are the only remaining structures not automatically placed.)</p> <figure> <video src="/assets/video/Overmind_RCL_1-4_Timelapse_h265.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" autoplay="" controls="" loop=""/> </figure> <p>Unfortunately, I did have to displace several existing players in the respawn zone I picked into. The first few players I eliminated presented very little resistance - one or two towers with unreliable refilling code. A single sieger/healer pair was sufficient to take them out over the course of a few hours.¬†I felt a little bad taking them out, but that‚Äôs just the nature of the game.</p> <h1 id="nip-it-in-the-bud">Nip it in the bud</h1> <p>After I had taken over about half of my sector, I noticed that Tigga, a very experienced player, had respawned from shard0 to one of the central rooms in my sector. He used to live a few sectors away from me in shard0, and I‚Äôve watched his combat code work; it is much more developed than mine currently is. This (along with the fact that he has an additional 7 GCL on me) made me confident that I would not win a war of attrition if I allowed his colony to reach the point where boosts were available, so I prioritized dusting off some deprecated combat and boosting code to take out his room.</p> <p>This was hardly a fair fight, however: I did have the huge advantage of having spawned over a week before he did, so I had a much larger economy to leverage. Tigga‚Äôs code expands fast, and he was remote mining and poaching energy from my neighboring rooms as early as RCL2. I quarantined his room, placing persistent guard and swarmGuard directives on all neighboring rooms to slow his expansion while his safemode was active. His combat creeps put up a good fight, frequently beating mine in equally-sized conflicts with what was clearly very polished kiting code.</p> <p>However, his AI seemed to prioritize fighting over expanding, and he kept pumping out fighters at the cost of under-saturating his own room‚Äôs sources. Since I had far more resources at my disposal, I kept sending my comparatively dumb creeps to die to keep him occupied, and, in the end, I ended up taking out his RCL4 room with a pair of boosted destroyers. It seems that room quarantining was a very effective strategy here, and I‚Äôve started writing a Ravager overlord that will harass and deny expansions more efficiently. I was able to use the boosting and combat code I had developed to clear out the rest of the sector, and things were peaceful until my respawn zone walls came down.</p> <h1 id="losing-my-first-room">Losing my first room</h1> <p>Almost immediately, my neighbor to the east, BrianRotel, started attacking my nearest room. According to <a href="http://www.leagueofautomatednations.com/map/shard2/bots">LoAN</a>, he is running KasamiBot, which has some decent dismantling code, and he already had a large number of RCL8 rooms and a much larger economy than mine. I had to leave for the weekend about an hour after his attack started, but I was able to quickly cobble together some decent <a href="https://github.com/bencbartlett/Overmind/blob/master/src/overlords/combat/overlord_archer.ts">archer defense code</a>¬†that I was confident would hold him off and deployed it before I had to leave.</p> <p>Unfortunately, a subtle bug in the colony Overseer prevented it from triggering. Since I was unable to fix the bug over the weekend, he was able to take out my room and has, so far, thwarted my efforts to rebuild it. However, my defensive code works quite well now, as he has unsuccessfully attacked another one of my rooms, and since he is running an open-source bot with no noticeable modifications, I‚Äôm not too worried about defending against novel new attack strategies. So, for the time being, I‚Äôve ignored my lost room and focused most of my efforts into finishing my overhauled logistics system.</p> <p>I‚Äôve never actually lost a room prior to this event (other than during the first week of me playing Screeps), so this was a good learning experience. It‚Äôs also made me reconsider my classic ‚Äúbox and flower‚Äù room layout. It has a number of (mainly logistical) advantages to it: it allows for flexibility on where to place the important room components in the Command Center (box) without worrying about the bulk of the Hatchery (flower), it integrates well with my simple but flexible link management code, and I just generally like the aesthetics of the layout. However, I‚Äôm not sure that it‚Äôs an optimal layout from a defensive standpoint: having walls far away from towers minimizes turret damage, and its two-part nature prevents me from defending inside the walls, as manager creeps need to safely get from the hatchery to the command center to keep the energy flow going. I may be switching to using bunkers in the near future, but that is a post for another day.</p> <h1 id="work-smart-not-hard">Work smart, not hard</h1> <p>Combat has never really been my first priority in playing Screeps, but my recent power struggles have distracted me from fixing logistic inefficiencies. One item that has been on the back burner for a while now has been better road maintenance. Prior to my recent rewrite and respawn, every hauler had a single work part and would maintain the roads they were on. However, this can actually get surprisingly expensive, and the pricey work parts are only actively in use for a small portion of the time, so I got rid of this behavior in the rewrite.</p> <p>Since then, I‚Äôve slapped a bandaid on the problem and just had my workers stop what they are doing to repair any critical roads and to look for any roads within range 3 to repair whenever they can, if it won‚Äôt interrupt whatever else they did that tick. A cute little <a href="https://github.com/bencbartlett/Overmind/blob/master/src/Zerg.ts#L203"><code class="language-plaintext highlighter-rouge">canExecute()</code></a> property I added allows my creeps to determine if a given action will block other actions they have tried to execute this tick; this way, I can stop looking up¬†<a href="http://docs.screeps.com/simultaneous-actions.html">what‚Äôs probably the most-referenced page on the Screeps documentation</a>.</p> <p>I‚Äôve waffled back and forth on how to make a permanent solution to this. I considered making a dedicated paver overlord to handle this, but this seemed redundant, as the creep would likely have a similar body to a worker creep, so I opted against this. I also considered adding work parts only to some haulers, and having them prioritize routes with low road health, but this would complicate my super-beautiful upcoming logistics system. <em>(Can you tell I‚Äôm excited about this?)</em></p> <p>Eventually, I settled on writing a <a href="https://github.com/bencbartlett/Overmind/blob/master/src/logistics/RoadLogistics.ts"><code class="language-plaintext highlighter-rouge">RoadLogistics</code></a> class which allows workers to more efficiently handle road maintenance. Each colony is given a roadLogistics object, which tells workers when they should repair the roads in a room. Only one worker is assigned to a given room needing maintenance, and maintenance is only needed if (1) there is a road below critical health in the room, or (2) the total amount of energy needed to repair the room reaches the worker‚Äôs carryCapacity. This has allowed workers to waste less time traveling around random places to inefficiently repair roads and has cut back on the CPU overhead of having to look for nearby roads to idly repair.</p> <h1 id="now-these-points-of-data-make-a-beautiful-line">Now these points of data make a beautiful line‚Ä¶</h1> <p>Overmind now has graphs! Beautiful, beautiful graphs! I‚Äôve finally gotten around to setting up Grafana using <a href="https://screepspl.us/services/grafana">ScreepsPlus</a>, and it was surprisingly straightforward. (Shoutout to ags131 for keeping this great service running!) If you‚Äôre one of the half-dozen people running Overmind on the public servers, I‚Äôd highly recommend setting this up; bonzaiferroni has <a href="https://github.com/bonzaiferroni/bonzAI/wiki/Screepspl.us-agent-with-Compute-Engine">a great tutorial</a> on how to get started. If you do set it up, here‚Äôs what you can expect it to look like out of the box:</p> <p><img src="/assets/img/screen-shot-2018-03-11-at-5-51-30-pm.png" alt="Screen Shot 2018-03-11 at 5.51.30 PM" class="img-fluid rounded z-depth-0"/></p> <h1 id="and-were-out-of-beta-were-releasing-on-time">‚Ä¶and we‚Äôre out of beta, we‚Äôre releasing on time!</h1> <p>I‚Äôve been saying this for a year now, but Overmind is almost ready for a v1.0 release. In fact, I finally made the very first (pre-)release on Github as v0.1! I‚Äôll make a v0.2 release containing many of the changes mentioned in this post when I deploy the updated logistics system on the public servers later this week.</p> <p>I want to take the remainder of this post to talk about my plans for the near future of the project. At this point, here are the remaining things I want to implement before a v1.0 release:</p> <ul> <li>I want Overmind to be able to run completely autonomously, such that it can be run as an opponent on private servers, so I need to implement automated room planning. My <a href="https://bencbartlett.wordpress.com/2018/02/06/screeps-2-interior-design/">room planning system</a> is already semi-automated, so I‚Äôm not anticipating this to be a huge hurdle, as I just need to design a system to calculate the best places to place the flags.</li> <li>I also need to implement automated room/expansion claiming. This will likely be a bit more involved, and will require me to write more extensive scouting code, but I don‚Äôt think it will be a super long process to implement.</li> <li>I now already have some decent automated defensive code, but I need to make automatic harassment and attacking code. I have some ideas brewing for this, but I‚Äôm not sure how long it will take.</li> <li>As I mentioned in my previous post, I want to take some parts of my code, including Tasks, Colonies, and my new logistics system and release them as drag-and-drop plugins in a separate repository.</li> </ul> <p>I haven‚Äôt accepted any major contributions to the codebase yet, and I don‚Äôt plan to until a v1.0 release, but after that, I think I‚Äôll open up the project for anyone who wants to contribute to it. (You may have noticed that I‚Äôve added pull request and issue templates to the repository.)</p> <h1 id="an-anti-bot-bot">An anti-bot bot</h1> <p>Finally, I wanted to talk about the long-term future of Overmind as an open-source codebase. There was a really good <a href="https://screeps.com/forum/topic/2000/on-the-topic-of-open-source-code-bases">discussion</a> about the use of open-source codebases on the Screeps forum a few months ago, and I‚Äôve taken some ideas from there about this topic.</p> <p>When I first started playing Screeps over a year ago, screeps-OCS comprised what seemed like a large portion of the player base, easily stomping newbies who play the game as it is meant to be played by writing their own code. The fact that someone could just download a 10000-line bot and use it to steamroll my AI almost caused me to quit playing Screeps, and I see the prevalence of people running open-source codebases that they don‚Äôt actively contribute to as one of the single biggest flaws in the game.</p> <p>Even before an ‚Äúofficial release‚Äù, I‚Äôve seen several people running Overmind on the public servers. Although this is flattering, I¬†don‚Äôt want my AI to become a downloadable newbie-stomping oppression machine as it finishes development, so a while ago, I decided that my long term goal for Overmind is for it to be the ‚Äúanti-bot bot‚Äù. Now that there is an¬†<a href="http://www.leagueofautomatednations.com/vk/bots/members.json">easily accessible way</a>¬†to determine if people are running bots on public servers, I‚Äôll eventually be adding in behavioral changes to the AI which will cause it to preferentially target players using non-Overmind bots on the public servers and to limit aggression to non-threatening players in recent newbie zones. These parts of the codebase will be obfuscated and made intentionally difficult to disable. (This is also the main reason for the fourth clause in the somewhat silly and probably completely unenforcible license that I recently added to the repository.) I‚Äôm not yet sure how feasible this plan will be, but in an ideal world, this would allow me to keep most of my codebase open sourced while slightly controlling its behavior on public servers.</p> <p><em>Remember back when I said this would be a relatively short post? Me neither! Check back later this week for a post on solving the generalized problem of resource transport‚Ä¶</em></p>]]></content><author><name></name></author><category term="screeps"/><summary type="html"><![CDATA[This will be a relatively short post. I was originally planning on the main topic of this post to be my overhauled logistics system, but I have a¬†lot to say about that. It‚Äôs easily one of the coolest things I‚Äôve implemented in Screeps, so I‚Äôm giving it its own dedicated post - expect to hear from me again later this week!]]></summary></entry><entry><title type="html">Screeps #2: Interior Design</title><link href="https://bencbartlett.github.io/blog/screeps-2-interior-design/" rel="alternate" type="text/html" title="Screeps #2: Interior Design"/><published>2018-02-06T00:00:00+00:00</published><updated>2018-02-06T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-2-interior-design</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-2-interior-design/"><![CDATA[<p>Now that the dust has settled following the recent <a href="https://bencbartlett.wordpress.com/2018/01/15/screeps-1-overlord-overload/">massive rewrite of my AI</a>, I‚Äôve been able to turn my attention to adding more features to Overmind. Here‚Äôs a few of the things I‚Äôve been working on‚Ä¶</p> <h1 id="room-planning">Room planning</h1> <p>Overmind finally hired an interior decorator! I‚Äôve been developing a semi-automatic room planning system for the last month or so, beginning slightly before the rewrite. I‚Äôm a little OCD about room layouts and aesthetics, so I wanted to design a system that could be fully automated but also would allow for user input when choosing the layout. I‚Äôll discuss it in more detail below, but here‚Äôs a video of it in action:</p> <figure> <video src="/assets/video/Overmind_base_planner_h265.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" autoplay="" controls="" loop=""/> </figure> <p>Each colony¬†now includes a <a href="https://github.com/bencbartlett/Overmind/blob/8a9ca323091f15c56bb55957828cfc88da8aa4e2/src/roomPlanner/RoomPlanner.ts">RoomPlanner</a>, referenced as¬†<code class="language-plaintext highlighter-rouge">colony.roomPlanner</code>, which is responsible for generating a room layout and placing construction sites as needed to build the layout as the colony level increases. When you set¬†<code class="language-plaintext highlighter-rouge">colony.roomPlanner.active = true</code>¬†(I‚Äôm working on adding a set of console commands to make this simpler), the RoomPlanner opens a new planning session for you.¬†The planned layout is drawn using RoomVisuals each tick while the session is active.</p> <p>You can place flags of certain color codes (white/* is reserved for this) to place different types of HiveClusters around the room. For example, placing a white/green flag will place a hatchery, while a white/blue flag will place a command center. Activating a planning session will display a list of flag commands in the console. The cluster layouts are pre-designed using the text output from¬†<a href="http://screeps.dissi.me/buildingplanner/">Dissi‚Äôs building planner</a>¬†and the layouts for each RCL are stored in a large JSON object (example: <a href="https://github.com/bencbartlett/Overmind/blob/master/src/roomPlanner/layouts/hatchery.ts">hatchery</a>) containing the layouts and a bit of extra metadata. Placing a flag translates the layout to the appropriate location (set by the object which instantiates the corresponding hive cluster) and you can change¬†<code class="language-plaintext highlighter-rouge">flag.memory.rotation</code>¬†to set the rotation of the cluster. Some clusters, like mining sites, don‚Äôt require manual placement since their position can be inferred.</p> <p>The planner then computes the routes¬†to connect the clusters appropriately with roads using my <a href="https://github.com/bencbartlett/Overmind/blob/master/src/pathing/pathing.ts">Pathing</a> module (which interfaces heavily with Traveler), placing routes from the commandCenter to the hatchery, upgradeSite, and each miningSite. When¬†<code class="language-plaintext highlighter-rouge">Pathing.routeRoadPath()</code>¬†is called, it computes the shortest passable path between two locations, treating positions where a future building is planned as obstacles, and ignoring terrain values, such that every position has a cost of 2 in the pathfinder CostMatrix.</p> <p>One of the cooler features I‚Äôve added to the RoomPlanner is the ability to place routing hints with a white/white flag. These hints change the cost of the square they are placed on from 2 to 1, such that roads will preferentially be routed through the flag position, but only if the possible path lengths are degenerate. If the path planned using hints is longer than the shortest possible path, the errant path is drawn in red and a warning is displayed. This allows me to generate paths that would consistently satisfy functionality (being as short as possible) and aesthetics (no excessive zig-zags, merging nicely, etc.).</p> <p>When you‚Äôre happy with the planned layout and the RoomPlanner is also satisfied with it (requiring that a hatchery, a commandCenter, and an upgradeSite have been placed and that all planned building placements are valid), you can call¬†<code class="language-plaintext highlighter-rouge">colony.roomPlanner.finalize()</code>¬†to end your planning session and write everything to memory. This generates room plans for each RCL and serializes them into memory. Once the plan has been finalized, every $latex N$ ticks, the planner will check if there are structures and roads which need to be built and will place construction sites accordingly.</p> <p>Upon ending a session, the planner also removes all planning flags (white/*) you have placed across the colony, after saving the locations and types of them in its memory. You can reopen your session at a later time and the planner will restore the flags from the previous session, allowing you to easily modify the room plan in the future.</p> <h1 id="brave-new-world-shard">Brave new <del>world</del> shard</h1> <p>After fixing a few final bugs in my AI (including one¬†<a href="https://screeps.com/forum/topic/2084/creep-spawning-false-and-creep-tickstolive-undefined-on-private-server">incredibly frustrating one</a>¬†due to a bug in the private servers where overlords would occasionally spawn one additional creep beyond what was needed, depending on the state of the Hatchery‚Äôs production queue), I decided I‚Äôm finally ready to deploy the new version to the public servers and respawn to a faster-ticking shard.</p> <p>Earlier today, my Screeps abandoned <a href="https://screeps.com/a/#!/map/shard0?pos=-15.61,-87.714">their ancestral home</a> and respawned to¬†<a href="https://screeps.com/a/#!/room/shard2/E5S47">shard2, E5S47</a>. Feel free to check in if you‚Äôre interested in following my progress.</p> <h1 id="organs-for-sale">Organs for sale?</h1> <p>I‚Äôm very close to a 1.0 release of Overmind, and an idea I‚Äôve been tossing around recently is making a separate¬†<code class="language-plaintext highlighter-rouge">overmind-components</code>¬†repository on Github to host some of the more polished parts of my AI¬†as drag-and-drop plugins. I‚Äôve spent a disproportionately large amount of time writing a clean framework to work with for Screeps (at the expense of developing features), and I‚Äôve had several people message me on Slack/Reddit to ask for help integrating parts of my code into their AI‚Äôs, so I think the demand could definitely be there.</p> <p>To clarify, I would only be exporting ‚Äúframework‚Äù code, such as my¬†<code class="language-plaintext highlighter-rouge">Task</code>¬†system, which can simplify the syntax and complexity of writing decision trees for creeps, rather than ‚Äúfeature‚Äù code, which is stuff like combat, mining, and processing minerals that people should write for themselves.</p> <p>If you have thoughts on this or would be interested in helping me beta test these plugins, leave a comment here, in the <a href="https://www.reddit.com/r/screeps/comments/7vkr3n/screeps_2_interior_design/">Reddit post</a>, in the¬†<a href="https://screeps.slack.com/messages/overmind">#overmind</a>¬†Slack channel, or send me a DM¬†<a href="https://screeps.slack.com/messages/muon">@muon</a>. (I also accept carrier pigeons and, if you live near Palo Alto, smoke signals.)</p>]]></content><author><name></name></author><category term="screeps"/><summary type="html"><![CDATA[Now that the dust has settled following the recent massive rewrite of my AI, I‚Äôve been able to turn my attention to adding more features to Overmind. Here‚Äôs a few of the things I‚Äôve been working on‚Ä¶]]></summary></entry><entry><title type="html">Screeps #1: Overlord overload</title><link href="https://bencbartlett.github.io/blog/screeps-1-overlord-overload/" rel="alternate" type="text/html" title="Screeps #1: Overlord overload"/><published>2018-01-15T00:00:00+00:00</published><updated>2018-01-15T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-1-overlord-overload</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-1-overlord-overload/"><![CDATA[<p>In¬†<a href="https://bencbartlett.wordpress.com/2017/12/19/screeps-0-a-brief-history-of-game-time/">my last post</a>¬†I mentioned I‚Äôd be rewriting my Screeps AI. And what a rewrite this has been. After¬†8547 additions and 9953 deletions over the last few commits, I‚Äôve completely overhauled a huge amount of how my AI works. At first, there wasn‚Äôt any way to do this incrementally, the only strategy being ‚Äúturn it off and see what breaks‚Äù and at times I felt like I was wading through the compiler errors like a fat mining creep wading through a swamp: <img src="/assets/img/screen-shot-2017-12-26-at-5-55-40-pm.png" alt="Screen Shot 2017-12-26 at 5.55.40 PM" class="img-fluid rounded z-depth-0"/></p> <h1 id="my-shiny-new-ai">My shiny new AI</h1> <p>I‚Äôve made a lot of changes to the organization of the Overmind framework and I‚Äôm super happy with how they‚Äôve turned out. I think it‚Äôs getting very close to a 1.0 version which can be run as an opponent on private servers, and I almost decided to make this the 0.9 release, but I want to finish a few half-baked automation features first. I‚Äôll discuss each of the major changes in more detail below, but first, here‚Äôs a fancy new diagram!</p> <p><img src="/assets/img/aidiagram.png" alt="AIdiagram.png" class="img-fluid rounded z-depth-0"/></p> <p>If you‚Äôve seen the¬†<a href="https://github.com/bencbartlett/Overmind/blob/d6c399273d96b084718b065a027cf4a69e85a477/assets/AIdiagram.png">previous version of this diagram</a>, the first change you‚Äôve probably noticed is that there are no more roles! Each <code class="language-plaintext highlighter-rouge">Role</code> used to govern the creep control logic for a certain type of creep. All creep control logic, including what used to be on¬†<code class="language-plaintext highlighter-rouge">HiveCluster</code>s, and spawn request logic has been combined in the new¬†<code class="language-plaintext highlighter-rouge">Overlord</code>¬†class.</p> <p>Nerdy tangent: conceptually, the new¬†<code class="language-plaintext highlighter-rouge">Overlord</code>¬†class is actually the Overseer class I mentioned at the end of my last post, but I decided the name ‚ÄúOverlord‚Äù fit better thematically, since Overlords are responsible for relaying orders to the Zerg in Starcraft, which is what the class does. The remaining functionality of what used to be the¬†colony Overlord is now the colony¬†<code class="language-plaintext highlighter-rouge">Overseer</code>, which also thematically fits, since part of its function is to look for certain conditions in rooms and respond to them.</p> <h1 id="the-overmind-hierarchy">The Overmind hierarchy</h1> <p>Now let‚Äôs get in to how it all works. I‚Äôll explain the main components of the AI in decreasing order of hierarchy, but first, a brief glossary:</p> <ul> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Overmind.ts">Overmind</a></strong>: the top-level object that contains and runs colonies and wraps all game objects</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Colony.ts">Colony</a></strong>: groups together rooms and their objects into a single unit and instantiates HiveClusters</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/hiveClusters/HiveCluster.ts">HiveCluster</a></strong>: groups together structures with related functionality and their logic</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/directives/Directive.ts">Directive</a></strong>: a wrapper for a flag with contextual behavior changes</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/Overlord.ts">Overlord</a></strong>: handles creep spawning and control for a specific goal; can be plopped on any of the above three objects</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Overseer.ts">Overseer</a></strong>: tracks directives and overlords as they are instantiated and runs them by priority; places new directives to respond to stimuli</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/tasks/Task.ts">Task</a></strong>: a customizable object which you can hand to a creep with¬†<code class="language-plaintext highlighter-rouge">creep.task = Tasks.*</code>; generalizes the notion of ‚Äúdo action X to thing Y until condition Z is met‚Äù</li> <li><strong><a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Zerg.ts">Zerg</a></strong>: task- and overlord-contextualized wrapper for a creep</li> </ul> <h2 id="level-0-overmind-and-the-tick-cycle">Level 0: Overmind and the tick cycle</h2> <p>I‚Äôve simplified the structure of my¬†<a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/main.ts">main loop</a>¬†considerably in this rewrite. Excluding memory checking and sandbox code, there are now three major phases in each tick, each of which is executed by a call to the <a href="https://github.com/bencbartlett/Overmind/blob/12ed8718608c51eccd998a22acad0ba486cdc385/src/Overmind.ts">Overmind</a>:</p> <ol> <li><code class="language-plaintext highlighter-rouge">build()</code>¬†All caching and object instantiation is done in this phase. <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Overmind.ts#L31">Colonies and their overlords are instantiated</a>, then <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Colony.ts#L149">colonies instantiate their hive clusters</a> and their overlords. Finally, <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Overmind.ts#L92">directives and their overlords are instantiated</a>. (More on overlords below.)</li> <li><code class="language-plaintext highlighter-rouge">init()</code>¬†This phase handles all pre-state-changing actions, primarily various requests like <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/Overlord.ts#L106">creep spawning requests</a>¬†and¬†<a href="https://github.com/bencbartlett/Overmind/tree/dfcc17146de408112c1186b1a552d2be6572751c/src/resourceRequests">transport and link requests</a>.</li> <li><code class="language-plaintext highlighter-rouge">run()</code>¬†This is where the action happens. All state-changing actions happen here; most will require information that is populated in the <code class="language-plaintext highlighter-rouge">init()</code>¬†phase. HiveClusters will look through their various requests to determine what actions should be taken (<a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/hiveClusters/hiveCluster_hatchery.ts#L169">spawning the highest priority creep(s)</a> from the requests, <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/overlord_commandCenter.ts#L78">loading/unloading the storage link</a>, etc.). Overlords will scan through their Zerg and assign new tasks through a decision tree to each one that <code class="language-plaintext highlighter-rouge">[isIdle](https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Zerg.ts#L260)</code>, such as <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/overlord_mine.ts#L41">maintaining a miningSite</a>, <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/overlord_supply.ts#L38">determining which structures to supply</a>, or <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/overlord_haul.ts#L52">hauling back energy from a remote source</a>. The Overseer examines each room to look for any anomalous conditions, such as an <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Overseer.ts#L29">invasion</a> or a <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/Overseer.ts#L39">colony crash</a>, and responds by placing Directives accordingly.</li> </ol> <h2 id="level-1-colonies-hive-clusters-and-directives">Level 1: Colonies, Hive Clusters, and Directives</h2> <p>Not much has changed here; as before, the main idea behind colonies and hive clusters is to organize what belongs to what in a hierarchical manner based on what each object is instantiated by. Colonies are instantiated by an owned room and a list of outpost rooms (determined by directives) and organize these rooms into a single unit. HiveClusters are instantiated by a RoomObject belonging to a colony and group multiple structures and components together which share related functionality. Both Colonies and HiveClusters can have overlords put on them.</p> <p>Directives are on the same hierarchical level as HiveClusters, but they are a little different, since the colony does not directly instantiate them. They are instantiated from flags by the Overmind and assigned to a colony based on their location. Directives don‚Äôt have much internal logic (some will remove themselves, but that‚Äôs about as complex as it gets right now) but their main function is to be a conditional attachment point for overlords. Directives are categorized by color codes, with the primary color indicating a category and a secondary color indicating the specific type. I‚Äôve currently only written a few of the most essential directives, but the categories I have in mind are:</p> <ul> <li>Purple: colony directives - territory (claiming/reserving rooms and grouping rooms in colonies) and colony operations (incubating lil‚Äô babby colony)</li> <li>Red: military directives - defend against NPC invaders, attack a room, etc.</li> <li>Orange: operational directives - deal with non-standard colony conditions, like recovering from a crash with a bootstrapping directive</li> <li>Yellow: energy and resource directives</li> <li>White: RoomPlanner directives (more about this in the next post!), which allow for guided planning of colonized rooms, such as positioning hive clusters and placing road routing waypoints.</li> </ul> <h2 id="level-2-overlords-and-overseers">Level 2: Overlords and Overseers</h2> <p>Overlords are really the heart of this update, if you couldn‚Äôt tell by the title of this post. An Overlord is a generalization of a set of related things that need to be done in a colony like mining from a site, bootstrapping a new colony, guarding against invaders, or building construction sites. Overlords handle spawning or obtaining suitable creeps to do these things and contain the actual implementation of doing them, replacing the messy <code class="language-plaintext highlighter-rouge">Objective</code>¬†system in the older AI. If HiveClusters are the organs of a colony, Overlords are the biological processes which make those organs function.</p> <p>One of the biggest (and hardest) design decisions I had to make with this rewrite was how to handle instantiation of Overlords. Initially, I was drawn toward using directives as the only instantiation method, such that every process in a colony would have its own flag. However, I decided against this idea for two reasons: (1) it seemed to be unnecessary and unintuitive to use directives for normal operation (HiveClusters would need to be changed to be instantiated from flags, which is against their design, or would have a split cluster-directive nature which I didn‚Äôt like) and (2) there is speculation that the flag cap may eventually be lowered from 10,000 to 100, so I don‚Äôt want to rely on flags too heavily.</p> <p>Eventually, I decided that an overlord can be instantiated from anything that has the following properties:</p> <ul> <li><code class="language-plaintext highlighter-rouge">name</code>: for generating unique Overlord references</li> <li><code class="language-plaintext highlighter-rouge">room</code>: an Overlord handles operations which primarily take place in one room</li> <li><code class="language-plaintext highlighter-rouge">pos</code>: Overlords must be instantiated from a physical object</li> <li><code class="language-plaintext highlighter-rouge">colony</code>: for assigning which colony handles the spawn requests (I added a self-referencing <code class="language-plaintext highlighter-rouge">Colony.colony</code> property so that Colonies could instantiate Overlords as well)</li> <li><code class="language-plaintext highlighter-rouge">memory</code>: Overlord memory is stored in <code class="language-plaintext highlighter-rouge">instantiator.memory.overlords[this.ref]</code></li> </ul> <p>This allows Overlords to be instantiated from a Colony, HiveCluster, or Directive, which makes them a very versatile control model. Colony overlords are for constant, colony-wide operations, like handling workers to build new things. HiveCluster overlords are more specialized but still always present, like spawning miners for a site or a dedicated Hatchery attendant. Directive overlords tend to be conditional, like guarding against NPC invaders or claiming a new room.</p> <p>When an Overlord is instantiated with a specified priority, it automatically adds itself to a priority queue on the colony <code class="language-plaintext highlighter-rouge">Overseer</code>. The Overseer is responsible for running all Directives and Overlords, as well as placing new Directives to respond to various stimuli.</p> <h1 id="what-else-is-new">What else is new?</h1> <p>The changes I‚Äôve discussed above are the largest changes that affect the core architecture of the AI, but I‚Äôve added a ton of other improvements over the last month(s).</p> <h2 id="overlord-overload-interface-underload"><code class="language-plaintext highlighter-rouge">Overlord</code> overload, <code class="language-plaintext highlighter-rouge">Interface</code> underload</h2> <p>If you‚Äôve looked at my codebase before, you‚Äôve probably noticed that almost every parent-level class was declared as¬†<code class="language-plaintext highlighter-rouge">export class Foo implements IFoo</code>, where¬†<code class="language-plaintext highlighter-rouge">IFoo</code>¬†is an interface enumerating the public properties and methods of¬†<code class="language-plaintext highlighter-rouge">Foo</code>¬†declared in one of the <a href="https://github.com/bencbartlett/Overmind/tree/31b721ba01750e27ab74877908fcf96539c07721/src/declarations">declaration files</a>, a similar paradigm to header files in C. In many cases, this is unnecessary in TypeScript, since the compiler can directly infer the types of class instances from the class declaration itself.</p> <p>However, there was a method to my madness: because of the very hierarchical structure of my AI, I needed a top-level globally accessible object so that game objects could access ‚Äúvirtual‚Äù game objects with prototype extensions, such as:</p> <p><code class="language-plaintext highlighter-rouge">flag.colony --&gt; Overmind.Colonies[Overmind.colonyMap[flag.room.name]</code></p> <p>In order for the object to be globally declared, it must be declared in a declaration file. Since <a href="https://stackoverflow.com/questions/39040108/import-class-in-definition-file-d-ts">declaration files can‚Äôt contain top-level imports</a>, the objects must be either typed as¬†<code class="language-plaintext highlighter-rouge">any</code>, which I didn‚Äôt like, or must have their properties enumerated by an interface.</p> <p>However, this got pretty tiring to maintain after a while, since every time I added or changed a method or property of a class, I‚Äôd need to keep updating the corresponding interface. With this update, I moved farther away from prototypes, deleting or moving a huge amount of prototypes I had in previous versions. The reduced use of prototypes allowed me to limit the number of top-level references, changing the typing of <code class="language-plaintext highlighter-rouge">global.Overmind</code> to¬†<code class="language-plaintext highlighter-rouge">any</code>. (Any time this is referenced, the corresponding request is wrapped as a definitely-typed output; for example, many things reference¬†<code class="language-plaintext highlighter-rouge">Directive.colony</code>, which references <code class="language-plaintext highlighter-rouge">Overmind.colony</code>.) Since removing most of the use of interfaces in my code, I‚Äôve found development speed has increased noticeably.</p> <h2 id="a-whole-family-oftasks">A whole family of¬†<code class="language-plaintext highlighter-rouge">Task</code>s!</h2> <p>I‚Äôve cleaned up my Task code a little bit, but the biggest change is that tasks can now have parents! When a task is finished executing, it automatically sets <code class="language-plaintext highlighter-rouge">this.creep.task = this.parent</code>¬†(which is¬†<code class="language-plaintext highlighter-rouge">null</code>¬†by default). This means you can call¬†<code class="language-plaintext highlighter-rouge">task.fork()</code>¬†to chain tasks together, which will come in handy for some of the logistics refactoring I‚Äôm planning in the future. For example, if you wanted to retrieve energy from two mining sites on a similar route and then drop off at storage, you could do:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">task</span> <span class="o">=</span> <span class="nx">Tasks</span><span class="p">.</span><span class="nf">withdraw</span><span class="p">(</span><span class="nx">miningSite1</span><span class="p">.</span><span class="nx">output</span><span class="p">);</span> 
<span class="nx">task</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">Tasks</span><span class="p">.</span><span class="nf">withdraw</span><span class="p">(</span><span class="nx">miningSite2</span><span class="p">.</span><span class="nx">output</span><span class="p">);</span> 
<span class="nx">task</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">Tasks</span><span class="p">.</span><span class="nf">deposit</span><span class="p">(</span><span class="nx">colony</span><span class="p">.</span><span class="nx">storage</span><span class="p">);</span> 
<span class="nx">creep</span><span class="p">.</span><span class="nx">task</span> <span class="o">=</span> <span class="nx">task</span><span class="p">;</span>
</code></pre></div></div> <p>Also, because I‚Äôm a little bit OCD about code aesthetics, I‚Äôve added a new¬†<code class="language-plaintext highlighter-rouge">Tasks</code>¬†module to wrap task instances, changing the default task assignment paradigm from¬†<code class="language-plaintext highlighter-rouge">creep.task = new TaskFoo(target)</code>¬†to¬†<code class="language-plaintext highlighter-rouge">creep.task = Tasks.foo(target)</code>.</p> <h2 id="a-better-feed-me-box">A better ‚Äúfeed me‚Äù box</h2> <p>If you look at my code for <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/overlord_haul.ts">haulers</a> and <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/overlords/overlord_supply.ts">suppliers</a>, you‚Äôll notice that there‚Äôs very little logic for figuring out what structures to deposit to or withdraw from. Aside from bootstrapping after a crash, almost every resource-moving operation in the AI now uses <code class="language-plaintext highlighter-rouge">[TransportRequests](https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/resourceRequests/TransportRequestGroup.ts)</code> to get what they need. This was in previous versions of the AI, but I‚Äôve added a lot of improvements and, with the removal of the objective system, generally use it more consistently throughout the code.</p> <h1 id="coming-soon-to-a-repository-near-you">Coming soon‚Ñ¢ to a repository near you</h1> <p>I think that Overmind is¬†(finally) nearing a workable release that could be run as an opponent on a private server. It‚Äôs not quite ready yet, so don‚Äôt expect much if you download it and leave it to its own devices, but it‚Äôs almost there. Here‚Äôs a few of the finishing touches it needs:</p> <ul> <li>I‚Äôve been able to hammer away bugs a lot faster with the new AI framework, but there are still a few bugs I‚Äôm trying to fix (including one very annoying bug where creeps will very occasionally get stuck in an infinite loop of entering and exiting a room on exit tiles).</li> <li>The defense code is still pretty simplistic, and I haven‚Äôt yet implemented SK mining or (re-)implemented boosting and mineral processing, but I think the new framework will allow me to work pretty quickly toward these goals.</li> <li>I want to respawn to shard1 or shard2 and move the new code to the public server! I‚Äôm hoping I can do this in the next week or so to make the February leaderboards without having to start the month from a fresh spawn.</li> <li>For an AI to be run as a bot on a private server, it needs to be completely autonomous. I still have to implement reservation- and claiming-planning systems, but at a surface level <a href="https://xkcd.com/793/">this seems to be a relatively straightforward optimization problem</a>, so I‚Äôm hopeful this won‚Äôt be too much of an undertaking.</li> <li>I‚Äôve been working on some automated <a href="https://github.com/bencbartlett/Overmind/blob/dfcc17146de408112c1186b1a552d2be6572751c/src/roomPlanner/RoomPlanner.ts">room planning features</a>¬†which can be run in automatic or guided-manual modes. These features are basically finished as of the <a href="https://github.com/bencbartlett/Overmind/tree/dfcc17146de408112c1186b1a552d2be6572751c">latest commit</a>, but I‚Äôve already been rambling for a long time and I think they‚Äôre cool enough to deserve their own post, so I‚Äôll talk about them in the next one.</li> </ul>]]></content><author><name></name></author><category term="screeps"/><summary type="html"><![CDATA[In¬†my last post¬†I mentioned I‚Äôd be rewriting my Screeps AI. And what a rewrite this has been. After¬†8547 additions and 9953 deletions over the last few commits, I‚Äôve completely overhauled a huge amount of how my AI works. At first, there wasn‚Äôt any way to do this incrementally, the only strategy being ‚Äúturn it off and see what breaks‚Äù and at times I felt like I was wading through the compiler errors like a fat mining creep wading through a swamp:]]></summary></entry><entry><title type="html">Screeps #0: A Brief History of Game.time</title><link href="https://bencbartlett.github.io/blog/screeps-0-a-brief-history-of-game-time/" rel="alternate" type="text/html" title="Screeps #0: A Brief History of Game.time"/><published>2017-12-19T00:00:00+00:00</published><updated>2017-12-19T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/screeps-0-a-brief-history-of-game-time</id><content type="html" xml:base="https://bencbartlett.github.io/blog/screeps-0-a-brief-history-of-game-time/"><![CDATA[<h2 id="screeps-like-starcraft-at-0001-speed">Screeps: like Starcraft at 0.001% speed</h2> <p>If you knew me in early 2017, you probably knew I became entirely too invested writing an AI for the programming strategy game¬†<a href="https://screeps.com/">Screeps</a>. (If you didn‚Äôt know me in early 2017, it‚Äôs probably because I was hiding in my room programming.)</p> <p>Like most RTS games, the core objective of Screeps is to expand your territory and defend against other players. However, unlike most RTS games, you cannot actively control your units; you must instead write code to govern their behavior using JavaScript (or a transpiled language). The units run in real-time even when you aren‚Äôt actively playing the game, and the game progresses on the scale of weeks or months, so the more you can automate, the better.</p> <p>Since I started playing the game - exactly 11 months ago as of today - I‚Äôve created a Screeps AI,¬†with some ~50,000 additions to the GitHub repository, which I dubbed <a href="http://github.com/bencbartlett/overmind">Overmind</a>¬†(much of the code is vaguely Starcraft-themed). I stopped playing the game for a few months over the last summer, but I was recently surprised to find my code was still running like a well-oiled machine on the public servers, so I decided to pick the game back up again. There‚Äôs a lot of changes and improvements I‚Äôd like to make, and I‚Äôve enjoyed reading <a href="https://arcath.net/category/screeps/">other people‚Äôs blogs</a> about their evolving Screeps AI‚Äôs, so I‚Äôve decided to start my own.</p> <h2 id="overmind-a-brief-history">Overmind: a brief history</h2> <p>Any large programming project has an iterative write-deploy-rewrite rhythm to it, but some rewrites are larger than others. I can break down the history of my Screeps AI to five stages, separated by the largest rewrites:</p> <ol> <li><a href="https://github.com/bencbartlett/Overmind/tree/1c2c0af0d9d9a9d5669ef9c9a62aca53d3e28be0">My first AI</a> was effectively a state machine hastily written in Javascript to bootstrap my entry into the world of Screeps. It had a few simple roles, like harvesters and haulers, and didn‚Äôt have much in the way of collective or inter-creep organization.</li> <li><a href="https://github.com/bencbartlett/Overmind/tree/9e525cb7109f0a4b0704613f0c27e46df1463cb4">The second version</a>¬†(first rewrite) refactored the roles into extensible classes and added a collective¬†<a href="https://github.com/bencbartlett/Overmind/blob/9e525cb7109f0a4b0704613f0c27e46df1463cb4/Brain_Room.js"><code class="language-plaintext highlighter-rouge">RoomBrain</code></a>¬†object to prioritize tasks and assign them to creeps in the most efficient order possible, functioning a little bit like a greedy scheduling algorithm dispatching processes in an OS. It also added <a href="https://github.com/bencbartlett/Overmind/blob/9e525cb7109f0a4b0704613f0c27e46df1463cb4/Task.js"><code class="language-plaintext highlighter-rouge">Task</code></a>¬†objects to more concisely tell creeps what to do and when to stop doing it, and it added the first instances of behavior modifications and military capabilities, with¬†<a href="https://github.com/bencbartlett/Overmind/blob/9e525cb7109f0a4b0704613f0c27e46df1463cb4/flag_millitary.js">flags</a>¬†functioning as injectable code snippets to modify the standard behavior.</li> <li><a href="https://github.com/bencbartlett/Overmind/tree/dfe55cd414624ad8b1b17e42c5a34454d972120b">In version 3</a>, I rewrote the entire AI using TypeScript, after my ballooning codebase began to become riddled with runtime errors which could easily be fixed by a strong type system. I found structNullChecks to be especially valuable, since many of the errors I was getting were when I was unsafely trying to access a nonexistent object. Migrating to TypeScript changed the general flavor of much of my code, and my AI became super object-oriented in the next rewrite.</li> <li><a href="https://github.com/bencbartlett/Overmind/tree/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src">The fourth version</a> of the AI is where I left off over last summer. As I was expanding quickly, I needed a stronger and more flexible way to deal with objects across multiple rooms. So, I introduced <a href="https://github.com/bencbartlett/Overmind/blob/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src/Colony.ts">Colonies</a>¬†to group together outposts operated by a single owned room and <a href="https://github.com/bencbartlett/Overmind/wiki/Design:-Hive-Clusters">Hive Clusters</a>¬†to group creeps and structures with a similar purpose (for example, spawning structures in a <a href="https://github.com/bencbartlett/Overmind/blob/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src/hiveClusters/Hatchery.ts"><code class="language-plaintext highlighter-rouge">Hatchery</code></a>). Although colonies greatly simplified the process of programming just about everything (instead of finding sources across multiple rooms filtered rooms, you can just say colony.sources), it added significant CPU overhead, so I added a more advanced <a href="https://github.com/bencbartlett/Overmind/blob/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src/preprocessing.ts">preprocessing</a> system to avoid doing duplicate searches in the same tick. I also added <a href="https://github.com/bencbartlett/Overmind/blob/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src/objectives/objectives.ts"><code class="language-plaintext highlighter-rouge">Objective</code>s</a>, which dispense tasks when assigned to a creep. To more finely control which creeps can do what actions, allowing for dedicated creeps to attend to certain clusters, I added <a href="https://github.com/bencbartlett/Overmind/blob/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src/objectives/ObjectiveGroup.ts"><code class="language-plaintext highlighter-rouge">ObjectiveGroup</code>s</a> and <a href="https://github.com/bencbartlett/Overmind/blob/fe44a3b93602eb1f6ee7e26bf0c9e7ad8e632874/src/resourceRequests/ResourceRequestGroup.ts"><code class="language-plaintext highlighter-rouge">ResourceRequestGroup</code>s</a>, which allow you to group together some subset of the operations that need to be done within a colony, so that only certain creeps will access them. (For example, only the hatchery attendants should refill the hatchery extensions.)</li> <li>In <a href="https://github.com/bencbartlett/Overmind/tree/a5637d5cad1542ca30844d13be9fc233b64eec36">the current version</a> of the AI, I haven‚Äôt made any radical changes yet, but I‚Äôve began experimenting with some new features, such as¬†<a href="https://github.com/bencbartlett/Overmind/tree/a5637d5cad1542ca30844d13be9fc233b64eec36/src/directives"><code class="language-plaintext highlighter-rouge">Directive</code>s</a>, which represent a more advanced method of behavior modification, and¬†<a href="https://github.com/bencbartlett/Overmind/tree/a5637d5cad1542ca30844d13be9fc233b64eec36/src/roomPlanner">automatic room planning</a>. Slowly but surely, I think I‚Äôm beginning to decide on a concrete direction to take the next rewrite.</li> </ol> <h2 id="the-good-the-bad-and-the-ugly">The good, the bad, and the ugly</h2> <p>Over the last few weeks, I‚Äôve spent a lot of time thinking about what I like and what I don‚Äôt like in my Screeps AI. Here‚Äôs a few of the things it does well:</p> <ul> <li>Colonies effectively abstractify away distinctions in rooms, making it very easy to program multi-room operations, such as container mining and hauling.</li> <li>Hive Clusters are an intuitive way to program related functionalities that offers a lot of fine control over the behavior of the creeps attending to the cluster. They are also good at designating specific functionalities for specific structures. For example, the Hatchery link, which always requests energy, is just <code class="language-plaintext highlighter-rouge">colony.hatchery.link</code>, and the Command Center link is <code class="language-plaintext highlighter-rouge">colony.commandCenter.link</code>, which is managed by <code class="language-plaintext highlighter-rouge">colony.commandCenter.manager</code>.</li> <li>Tasks are generally pretty good and minimize much of the decision-tree overhead that many AI‚Äôs feature, since a creep only needs to request a new task when its old one becomes invalid. While they are good at most actions, they aren‚Äôt the most flexible design, so they are bad for more complex scenarios where multiple actions should be executed, such as healing and attacking at the same time while trying to maintain a certain range. I‚Äôve added a few things to make them more process-like, including forking tasks and reverting to parent tasks, but they‚Äôre probably only good for about 80% of use cases.</li> <li>Directives are still pretty simple and limited in scope, but I think they are a pretty promising way to implement conditional behavior modification.</li> <li>My room planning system is gonna be really cool when I finish it! (More about that in a future post.)</li> </ul> <p>Now for the things I don‚Äôt like:</p> <ul> <li>Between Roles and Hive Clusters, I‚Äôve developed two very different programming paradigms for controlling creep actions. I generally prefer the latter, since the former can be pretty inflexible when coordinating multiple roles, but it‚Äôs obviously not suitable for all cases. However, I think there needs to be a single unified method for programming creep actions that combines the best of both paradigms.</li> <li>Because my AI instantiates so many book-keeping objects with Colonies and Hive Clusters, the initialization phase is really sensitive to the order in which you call things, since all of these objects can be pretty tightly interlinked.</li> <li>My AI sucks at low RCL, especially if I don‚Äôt have a grown colony to incubate the new one. This is mainly because I haven‚Äôt respawned since the very first rewrite of my AI, so I haven‚Äôt put much thought into how low-level code works. However, it‚Äôs also caused by bugs in the next bullet point.</li> <li>I like the idea of ObjectiveGroups, but I think the Objectives are an overly-complicated and buggy system. The way that the ObjectiveGroup dispenses tasks doesn‚Äôt offer very much intuition or control over what‚Äôs going on, and since objectives and tasks are closely related but different, it is possible for a creep to lose the task but still think it‚Äôs associated with the corresponding objective. This can cause fatal bugs at low RCL.</li> <li>My spawning code is pretty clean, but it gets called in many different locations. Hive clusters request creeps, Directives conditionally request creeps, and the colony <code class="language-plaintext highlighter-rouge">Overlord</code> randomly requests the remaining creeps. I want to consolidate the spawning requests to a single process.</li> <li>I‚Äôve spent so much time writing and rewriting the core framework of how my AI functions that I haven‚Äôt added entire sets of features to it. I‚Äôm almost done with room planning, but I still have very minimal military code and little to no trading or mineral processing capabilities. I‚Äôm hoping that this next rewrite will begin to set the final paradigm of how things are done in Overmind and that I can progress to adding new features to finish the AI.</li> </ul> <h2 id="a-rewrite-and-a-respawn">A rewrite and a respawn</h2> <p>Now that my first term of grad school is over, I finally have some time on my hands to make some major changes. I have a relatively solid idea of the general direction I‚Äôd like to take things, but I won‚Äôt give away too much:</p> <ul> <li>I think my first priority is rewriting the way I control creeps. I like how Hive Clusters control them, so I think I‚Äôm going to extract that creep control method along with all of the spawning requests scattered around, which follow a very similar pattern to each other, and put then in a new class: <code class="language-plaintext highlighter-rouge">Overseer</code>. I‚Äôm still figuring out exactly how this will work, but my thought is to tether creep control and spawning requests to a process that needs to be done, such as building construction sites, remote mining, or even creep-less processes such as managing link transfers. I want to make Overseers integrate cleanly with Hive Clusters but also make them independent so that structure-less or conditional operations, such as guarding a room from invaders, can be programmed using Overseers too.</li> <li>Currently, I have two main phases in each tick: <code class="language-plaintext highlighter-rouge">init()</code> and <code class="language-plaintext highlighter-rouge">run()</code>. I want to refactor the AI initialization by adding a <code class="language-plaintext highlighter-rouge">build()</code> phase (which I‚Äôve already started working on), so that it doesn‚Äôt matter which order you instantiate components in.</li> <li>Instantiating all of the book-keeping objects can be pretty CPU intensive. I recently read BonzAI‚Äôs <a href="https://github.com/bonzaiferroni/bonzAI/wiki/A-new-phase-for-bonzAI:-update()">post</a> where he‚Äôs started creating global objects that last between ticks. I think this might be even more useful in my case, since I basically rebuild the entire game environment with every tick. I‚Äôll probably split <code class="language-plaintext highlighter-rouge">build()</code> into <code class="language-plaintext highlighter-rouge">build()</code> and <code class="language-plaintext highlighter-rouge">rebuild()</code>. The former will get called once per node every global reset, and the latter will conditionally re-cache certain properties of objects.</li> </ul> <p>I‚Äôve made a ton of changes over the last few weeks preparing for this rewrite, and not all of them have gone over smoothly. I‚Äôve introduced several game-breaking bugs that have cause colony-wide blackouts, and now that I‚Äôve started doing most of my testing on a private server, I‚Äôve started to neglect my public server code. I‚Äôve also become kind of lonely with the <a href="http://blog.screeps.com/2017/08/shards/">release of shards</a>, since a good portion of shard0 has moved to the faster and more densely-packed shard1 and shard2. After I finish this rewrite, I think I‚Äôll try my luck and respawn in one of the new shards with my shiny new Screeps AI.</p>]]></content><author><name></name></author><category term="screeps"/><summary type="html"><![CDATA[Screeps: like Starcraft at 0.001% speed]]></summary></entry><entry><title type="html">How to Mathematica: a practical guide</title><link href="https://bencbartlett.github.io/blog/how-to-mathematica-a-practical-guide/" rel="alternate" type="text/html" title="How to Mathematica: a practical guide"/><published>2017-07-11T00:00:00+00:00</published><updated>2017-07-11T00:00:00+00:00</updated><id>https://bencbartlett.github.io/blog/how-to-mathematica-a-practical-guide</id><content type="html" xml:base="https://bencbartlett.github.io/blog/how-to-mathematica-a-practical-guide/"><![CDATA[<p>A few months ago, I gave an ‚Äúupperclassman workshop‚Äù to some of my housemates at Caltech on how to use Mathematica, specifically for use in problem sets. Mathematica is a mindbogglingly complex and expansive piece of software, but (at least for undergraduate physics curricula) there‚Äôs only a small subset of it that you need to know in order for it to be useful on problem sets. I try to cover all of these important features in my guide, along with some neat examples of things you might not have realized can be useful. The guide is available as a Mathematica notebook <a href="/assets/mathematica/MathematicaGuide.nb">here</a>, or as a PDF below.</p> <p><a href="/assets/pdf/MathematicaGuide.pdf" target="_blank" rel="noopener noreferrer"><i class="fas fa-file-pdf"></i></a> <a href="/assets/pdf/MathematicaGuide.pdf">How to Mathematica: A Practical Guide</a></p> <embed type="text/html" src="/assets/mathematica/MathematicaGuide.htm" style="width:100%; height:100vh"/>]]></content><author><name></name></author><category term="mathematica"/><summary type="html"><![CDATA[A few months ago, I gave an ‚Äúupperclassman workshop‚Äù to some of my housemates at Caltech on how to use Mathematica, specifically for use in problem sets. Mathematica is a mindbogglingly complex and expansive piece of software, but (at least for undergraduate physics curricula) there‚Äôs only a small subset of it that you need to know in order for it to be useful on problem sets. I try to cover all of these important features in my guide, along with some neat examples of things you might not have realized can be useful. The guide is available as a Mathematica notebook here, or as a PDF below.]]></summary></entry></feed>